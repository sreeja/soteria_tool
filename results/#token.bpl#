var V:[int]int;
var t:int;

//@invariant
function inv(V:[int]int, t:int) returns (bool)
{
    (forall r:int :: V[r] == 0 || V[r] == 1) && (exists r:int :: V[r] == 1) && (forall r, r0 :int :: (V[r] == 1 && V[r0] == 1) ==> r == r0)
}

//@gteq
function gteq_V(V1:[int]int, V2:[int]int) returns (bool);

axiom (forall V1, V2 :[int]int :: gteq_V(V1, V2) == true);

procedure transfer(from:int, to:int)
modifies V, t;
requires from != to;
requires V[from] == 1;
requires inv(V, t);
ensures t > old(t);
//ensures V[from] == 0;
//ensures (forall r:int :: (r != to ==> V[r] == 0));
//ensures V[to] == 1; 
ensures (forall r:int :: (r == to ==> V[r] == 1) && (r != to ==> V[r] == 0));
{
    V[to] := 1;
		V[from] := 0;
    t := t + 1;
}

procedure merge(V1:[int]int, t1:int) 
modifies V, t;
requires inv(V1, t1) == true;
/
requires t != t1;
ensures t == (if (old(t) > t1) then old(t) else t1);
ensures V == (if (old(t) > t1) then old(V) else V1);
{
    if (t1 > t)
    {
        t := t1;
        V := V1;
    }
}
