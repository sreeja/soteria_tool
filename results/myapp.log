18-01-30 16:32 INFO    : ************ sample ***************
18-01-30 16:32 INFO    : Checking the syntax
18-01-30 16:32 INFO    : Parsing the specification
18-01-30 16:32 INFO    : Checking the well-formedness of the specification
18-01-30 16:32 INFO    : Checking convergence
18-01-30 16:32 INFO    : Checking safety
18-01-30 16:32 INFO    : The specification is safe!!!
18-01-30 16:36 INFO    : ************ counter ***************
18-01-30 16:36 INFO    : Checking the syntax
18-01-30 16:36 INFO    : Parsing the specification
18-01-30 16:36 INFO    : Checking the well-formedness of the specification
18-01-30 16:36 INFO    : Checking convergence
18-01-30 16:38 INFO    : ************ counter ***************
18-01-30 16:38 INFO    : Checking the syntax
18-01-30 16:38 INFO    : Parsing the specification
18-01-30 16:38 INFO    : Checking the well-formedness of the specification
18-01-30 16:38 INFO    : Checking convergence
18-01-30 16:38 INFO    : Checking safety
18-01-30 16:42 INFO    : ************ counter ***************
18-01-30 16:42 INFO    : Checking the syntax
18-01-30 16:42 INFO    : Parsing the specification
18-01-30 16:42 INFO    : Checking the well-formedness of the specification
18-01-30 16:42 INFO    : Checking convergence
18-01-30 16:42 INFO    : Checking safety
18-01-30 16:42 ERROR   : __str__() missing 1 required positional argument: 'value'
18-01-30 16:47 INFO    : ************ counter ***************
18-01-30 16:47 INFO    : Checking the syntax
18-01-30 16:47 INFO    : Parsing the specification
18-01-30 16:47 INFO    : Checking the well-formedness of the specification
18-01-30 16:47 INFO    : Checking convergence
18-01-30 16:47 INFO    : Checking safety
18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 16:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:26 INFO    : ************ sample ***************
18-01-30 17:26 INFO    : Checking the syntax
18-01-30 17:26 INFO    : Parsing the specification
18-01-30 17:26 INFO    : Checking the well-formedness of the specification
18-01-30 17:26 INFO    : Checking convergence
18-01-30 17:26 INFO    : Checking safety
18-01-30 17:26 INFO    : The specification is safe!!!
18-01-30 17:26 INFO    : ************ counter ***************
18-01-30 17:26 INFO    : Checking the syntax
18-01-30 17:26 INFO    : Parsing the specification
18-01-30 17:26 INFO    : Checking the well-formedness of the specification
18-01-30 17:26 INFO    : Checking convergence
18-01-30 17:26 INFO    : Checking safety
18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:29 INFO    : ************ book_store ***************
18-01-30 17:29 INFO    : Checking the syntax
18-01-30 17:29 INFO    : Parsing the specification
18-01-30 17:29 INFO    : Checking the well-formedness of the specification
18-01-30 17:29 INFO    : Checking convergence
18-01-30 17:29 INFO    : Checking safety
18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_createOrder_addBook.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_createOrder_addBook.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_createOrder_addBook.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_createOrder_placeOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_createOrder_placeOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_createOrder_placeOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_createOrder_cancelOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_createOrder_cancelOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_createOrder_cancelOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_createOrder_processOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_createOrder_processOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_createOrder_processOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_addBook_createOrder.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_addBook_createOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_addBook_createOrder.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_addBook_placeOrder.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_addBook_placeOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_addBook_placeOrder.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_addBook_cancelOrder.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_addBook_cancelOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_addBook_cancelOrder.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_addBook_processOrder.bpl(156,1): Error BP5002: A precondition for this call might not hold.
results/stability_addBook_processOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_addBook_processOrder.bpl(152,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_placeOrder_createOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_placeOrder_createOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_placeOrder_createOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_placeOrder_addBook.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_placeOrder_addBook.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_placeOrder_addBook.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_placeOrder_cancelOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_placeOrder_cancelOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_placeOrder_cancelOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_placeOrder_processOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_placeOrder_processOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_placeOrder_processOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_cancelOrder_createOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_cancelOrder_createOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_cancelOrder_createOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_cancelOrder_addBook.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_cancelOrder_addBook.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_cancelOrder_addBook.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_cancelOrder_placeOrder.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_cancelOrder_placeOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_cancelOrder_placeOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_cancelOrder_processOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_cancelOrder_processOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_cancelOrder_processOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_processOrder_createOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_processOrder_createOrder.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_processOrder_createOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_processOrder_addBook.bpl(156,1): Error BP5002: A precondition for this call might not hold.
results/stability_processOrder_addBook.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_processOrder_addBook.bpl(152,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_processOrder_placeOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_processOrder_placeOrder.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_processOrder_placeOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:29 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_processOrder_cancelOrder.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_processOrder_cancelOrder.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_processOrder_cancelOrder.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_mergeOrders_createOrder.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_mergeOrders_createOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_mergeOrders_createOrder.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_mergeOrders_addBook.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_mergeOrders_addBook.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_mergeOrders_addBook.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_mergeOrders_placeOrder.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_mergeOrders_placeOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_mergeOrders_placeOrder.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_mergeOrders_cancelOrder.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_mergeOrders_cancelOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_mergeOrders_cancelOrder.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_mergeOrders_processOrder.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_mergeOrders_processOrder.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_mergeOrders_processOrder.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_createOrder_createOrder.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_createOrder_createOrder.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_createOrder_createOrder.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_addBook_addBook.bpl(150,1): Error BP5002: A precondition for this call might not hold.
results/stability_addBook_addBook.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_addBook_addBook.bpl(146,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_placeOrder_placeOrder.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_placeOrder_placeOrder.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_placeOrder_placeOrder.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_cancelOrder_cancelOrder.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_cancelOrder_cancelOrder.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_cancelOrder_cancelOrder.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-30 17:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_processOrder_processOrder.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_processOrder_processOrder.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_processOrder_processOrder.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:10 INFO    : ************ counter ***************
18-01-31 09:10 INFO    : Checking the syntax
18-01-31 09:10 INFO    : Parsing the specification
18-01-31 09:10 INFO    : Checking the well-formedness of the specification
18-01-31 09:10 INFO    : Checking convergence
18-01-31 09:10 INFO    : Checking safety
18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:16 INFO    : ************ counter ***************
18-01-31 09:16 INFO    : Checking the syntax
18-01-31 09:16 INFO    : Parsing the specification
18-01-31 09:16 INFO    : Checking the well-formedness of the specification
18-01-31 09:16 INFO    : Checking convergence
18-01-31 09:16 INFO    : Checking safety
18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0
results/stability_increment_decrement.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(136,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0
results/stability_increment_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0
results/stability_decrement_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0
results/stability_transfer_decrement.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0
results/stability_merge_decrement.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(135,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0
results/stability_merge_transfer.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(136,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:19 INFO    : ************ sample ***************
18-01-31 09:19 INFO    : Checking the syntax
18-01-31 09:19 INFO    : Parsing the specification
18-01-31 09:19 INFO    : Checking the well-formedness of the specification
18-01-31 09:19 INFO    : Checking convergence
18-01-31 09:19 INFO    : Checking safety
18-01-31 09:19 INFO    : The specification is safe!!!
18-01-31 09:20 INFO    : ************ sample ***************
18-01-31 09:20 INFO    : Checking the syntax
18-01-31 09:20 INFO    : Parsing the specification
18-01-31 09:20 INFO    : Checking the well-formedness of the specification
18-01-31 09:20 INFO    : Checking convergence
18-01-31 09:20 INFO    : Checking safety
18-01-31 09:20 INFO    : The specification is safe!!!
18-01-31 09:20 INFO    : ************ counter ***************
18-01-31 09:20 INFO    : Checking the syntax
18-01-31 09:20 INFO    : Parsing the specification
18-01-31 09:20 INFO    : Checking the well-formedness of the specification
18-01-31 09:20 INFO    : Checking convergence
18-01-31 09:20 INFO    : Checking safety
18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0
results/stability_decrement_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(135,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(137,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0
results/stability_transfer_decrement.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:28 INFO    : ************ counter ***************
18-01-31 09:28 INFO    : Checking the syntax
18-01-31 09:28 INFO    : Parsing the specification
18-01-31 09:28 INFO    : Checking the well-formedness of the specification
18-01-31 09:28 INFO    : Checking convergence
18-01-31 09:28 INFO    : Checking safety
18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_increment.bpl(116,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_increment.bpl(113,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_increment.bpl(115,11): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(116,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(113,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(115,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_transfer.bpl(116,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_transfer.bpl(113,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_transfer.bpl(115,13): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(134,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(130,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(135,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(131,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(140,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(135,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(131,2): anon0
results/stability_decrement_transfer.bpl(145,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(141,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(142,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(139,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(145,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(141,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(135,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(131,2): anon0
results/stability_transfer_decrement.bpl(145,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(141,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(143,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(140,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(133,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(130,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(134,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(117,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(131,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(127,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(123,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(110,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(125,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:48 INFO    : ************ counter ***************
18-01-31 09:48 INFO    : Checking the syntax
18-01-31 09:48 INFO    : Parsing the specification
18-01-31 09:48 INFO    : Checking the well-formedness of the specification
18-01-31 09:48 INFO    : Checking convergence
18-01-31 09:48 INFO    : Checking safety
18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_increment.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_increment.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_increment.bpl(111,11): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(111,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_transfer.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_transfer.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_transfer.bpl(111,13): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0
results/stability_decrement_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(135,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(137,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0
results/stability_transfer_decrement.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:49 INFO    : ************ counter ***************
18-01-31 09:49 INFO    : Checking the syntax
18-01-31 09:49 INFO    : Parsing the specification
18-01-31 09:49 INFO    : Checking the well-formedness of the specification
18-01-31 09:49 INFO    : Checking convergence
18-01-31 09:49 INFO    : Checking safety
18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_increment.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_increment.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_increment.bpl(111,11): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(111,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_transfer.bpl(112,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_transfer.bpl(109,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_transfer.bpl(111,13): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0
results/stability_decrement_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(135,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(137,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0
results/stability_transfer_decrement.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:49 INFO    : ************ counter ***************
18-01-31 09:49 INFO    : Checking the syntax
18-01-31 09:49 INFO    : Parsing the specification
18-01-31 09:49 INFO    : Checking the well-formedness of the specification
18-01-31 09:49 INFO    : Checking convergence
18-01-31 09:49 INFO    : Checking safety
18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(127,2): anon0
results/stability_decrement_transfer.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(135,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(137,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(131,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(127,2): anon0
results/stability_transfer_decrement.bpl(141,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(137,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(136,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(129,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(126,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(130,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(113,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(127,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(123,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(119,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 09:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(125,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(106,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(121,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 10:01 INFO    : ************ counter ***************
18-01-31 10:01 INFO    : Checking the syntax
18-01-31 10:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(91,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(88,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(90,9): anon0
results/counter.bpl(98,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(95,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(97,15): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 10:03 INFO    : ************ counter ***************
18-01-31 10:03 INFO    : Checking the syntax
18-01-31 10:03 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(91,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(88,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(90,9): anon0
results/counter.bpl(98,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(95,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(97,15): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 10:04 INFO    : ************ counter ***************
18-01-31 10:04 INFO    : Checking the syntax
18-01-31 10:04 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(93,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(89,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(92,9): anon0
results/counter.bpl(102,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(98,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(101,15): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 10:27 INFO    : ************ counter ***************
18-01-31 10:27 INFO    : Checking the syntax
18-01-31 10:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(108,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(104,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(107,15): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:32 INFO    : ************ counter ***************
18-01-31 10:32 INFO    : Checking the syntax
18-01-31 10:32 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(108,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(104,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(107,15): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:34 INFO    : ************ counter ***************
18-01-31 10:34 INFO    : Checking the syntax
18-01-31 10:35 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(108,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(105,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(107,15): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:43 INFO    : ************ counter ***************
18-01-31 10:43 INFO    : Checking the syntax
18-01-31 10:44 INFO    : Parsing the specification
18-01-31 10:44 INFO    : Checking the well-formedness of the specification
18-01-31 10:44 INFO    : Checking convergence
18-01-31 10:45 INFO    : Checking safety
18-01-31 10:46 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(127,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(124,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(126,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 10:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(143,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(143,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_increment.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_increment.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_increment.bpl(153,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(143,2): anon0
results/stability_decrement_transfer.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(153,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 10:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_merge.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_merge.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_merge.bpl(150,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_increment.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_increment.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_increment.bpl(153,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:51 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(127,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(143,2): anon0
results/stability_transfer_decrement.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(153,2): anon0

Boogie program verifier finished with 2 verified, 2 errors

18-01-31 10:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_merge.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_merge.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_merge.bpl(150,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(126,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(141,2): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 10:52 INFO    : ************ sample ***************
18-01-31 10:52 INFO    : Checking the syntax
18-01-31 10:52 INFO    : Parsing the specification
18-01-31 10:52 INFO    : Checking the well-formedness of the specification
18-01-31 10:52 INFO    : Checking convergence
18-01-31 10:52 INFO    : Checking safety
18-01-31 10:52 INFO    : The specification is safe!!!
18-01-31 10:52 INFO    : ************ sample ***************
18-01-31 10:52 INFO    : Checking the syntax
18-01-31 10:52 INFO    : Parsing the specification
18-01-31 10:52 INFO    : Checking the well-formedness of the specification
18-01-31 10:52 INFO    : Checking convergence
18-01-31 10:52 INFO    : Checking safety
18-01-31 10:52 INFO    : The specification is safe!!!
18-01-31 10:53 INFO    : ************ counter ***************
18-01-31 10:53 INFO    : Checking the syntax
18-01-31 10:54 INFO    : Parsing the specification
18-01-31 10:54 INFO    : Checking the well-formedness of the specification
18-01-31 10:54 INFO    : Checking convergence
18-01-31 10:54 INFO    : Checking safety
18-01-31 10:55 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(127,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(124,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(126,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 10:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(143,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 10:57 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(143,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 10:58 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(143,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(127,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(143,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(126,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(141,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:02 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(126,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(141,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:03 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(138,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(134,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:03 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(119,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(135,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:08 INFO    : ************ counter ***************
18-01-31 11:08 INFO    : Checking the syntax
18-01-31 11:08 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(9,80): Error: undeclared identifier: u
1 name resolution errors detected in results/counter.bpl

18-01-31 11:08 INFO    : ************ counter ***************
18-01-31 11:08 INFO    : Checking the syntax
18-01-31 11:09 INFO    : Parsing the specification
18-01-31 11:09 INFO    : Checking the well-formedness of the specification
18-01-31 11:09 INFO    : Checking convergence
18-01-31 11:10 INFO    : Checking safety
18-01-31 11:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(128,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(125,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(127,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 11:12 INFO    : ************ counter ***************
18-01-31 11:12 INFO    : Checking the syntax
18-01-31 11:14 INFO    : Parsing the specification
18-01-31 11:14 INFO    : Checking the well-formedness of the specification
18-01-31 11:14 INFO    : Checking convergence
18-01-31 11:15 INFO    : Checking safety
18-01-31 11:16 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(128,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(125,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(127,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 11:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(144,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:18 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(144,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(144,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:22 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(144,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:24 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(145,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(127,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(142,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:25 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(145,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(127,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(142,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:25 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(139,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(120,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(135,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(120,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(136,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:32 INFO    : ************ counter ***************
18-01-31 11:32 INFO    : Checking the syntax
18-01-31 11:32 INFO    : ************ counter ***************
18-01-31 11:32 INFO    : Checking the syntax
18-01-31 11:33 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/counter.bpl(109,1): Error BP5003: A postcondition might not hold on this return path.
results/counter.bpl(105,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/counter.bpl(108,15): anon0

Boogie program verifier finished with 3 verified, 1 error

18-01-31 11:34 INFO    : ************ counter ***************
18-01-31 11:34 INFO    : Checking the syntax
18-01-31 11:34 INFO    : Parsing the specification
18-01-31 11:34 INFO    : Checking the well-formedness of the specification
18-01-31 11:34 INFO    : Checking convergence
18-01-31 11:35 INFO    : Checking safety
18-01-31 11:36 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_decrement.bpl(129,1): Error BP5003: A postcondition might not hold on this return path.
results/safety_decrement.bpl(126,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/safety_decrement.bpl(128,7): anon0

Boogie program verifier finished with 0 verified, 1 error

18-01-31 11:36 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(145,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:36 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:38 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:38 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(132,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:39 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(143,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:39 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(128,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(146,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:39 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(140,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(121,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(136,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:39 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(121,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(140,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:43 INFO    : ************ counter ***************
18-01-31 11:43 INFO    : Checking the syntax
18-01-31 11:43 INFO    : Parsing the specification
18-01-31 11:43 INFO    : Checking the well-formedness of the specification
18-01-31 11:43 INFO    : Checking convergence
18-01-31 11:43 INFO    : Checking safety
18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(146,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-01-31 11:44 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(143,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(123,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(139,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-01-31 11:44 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(123,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 08:19 INFO    : ************ counter ***************
18-02-01 08:19 INFO    : Checking the syntax
18-02-01 08:19 INFO    : Parsing the specification
18-02-01 08:19 INFO    : Checking the well-formedness of the specification
18-02-01 08:19 INFO    : Checking convergence
18-02-01 08:19 INFO    : Checking safety
18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(146,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(143,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(123,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(139,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 08:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(123,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:53 INFO    : ************ counter ***************
18-02-01 11:53 INFO    : Checking the syntax
18-02-01 11:53 INFO    : Parsing the specification
18-02-01 11:53 INFO    : Checking the well-formedness of the specification
18-02-01 11:53 INFO    : Checking convergence
18-02-01 11:53 INFO    : Checking safety
18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(150,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(131,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(146,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(151,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(131,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(148,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(143,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(124,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(139,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(146,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(124,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(142,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:54 INFO    : ************ counter ***************
18-02-01 11:54 INFO    : Checking the syntax
18-02-01 11:54 INFO    : Parsing the specification
18-02-01 11:54 INFO    : Checking the well-formedness of the specification
18-02-01 11:54 INFO    : Checking convergence
18-02-01 11:54 INFO    : Checking safety
18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(134,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(135,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(150,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(132,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(147,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:54 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(132,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(149,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:55 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(144,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(125,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(140,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:55 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(147,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(125,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(143,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:56 INFO    : ************ counter ***************
18-02-01 11:56 INFO    : Checking the syntax
18-02-01 11:56 INFO    : Parsing the specification
18-02-01 11:56 INFO    : Checking the well-formedness of the specification
18-02-01 11:56 INFO    : Checking convergence
18-02-01 11:56 INFO    : Checking safety
18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(153,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(160,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(139,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(161,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(157,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(161,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(157,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(137,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(154,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(144,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(148,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 11:59 INFO    : ************ counter ***************
18-02-01 11:59 INFO    : Checking the syntax
18-02-01 11:59 INFO    : Parsing the specification
18-02-01 11:59 INFO    : Checking the well-formedness of the specification
18-02-01 11:59 INFO    : Checking convergence
18-02-01 11:59 INFO    : Checking safety
18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_decrement.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_decrement.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_decrement.bpl(153,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_increment_transfer.bpl(160,1): Error BP5002: A precondition for this call might not hold.
results/stability_increment_transfer.bpl(139,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_increment_transfer.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(161,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(157,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(161,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(157,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(154,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(136,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(151,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(157,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(137,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(154,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(148,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(129,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(144,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 12:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(152,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(148,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 13:12 INFO    : ************ counter ***************
18-02-01 13:12 INFO    : Checking the syntax
18-02-01 13:12 INFO    : Parsing the specification
18-02-01 13:12 INFO    : Checking the well-formedness of the specification
18-02-01 13:12 INFO    : Checking convergence
18-02-01 13:12 INFO    : Checking safety
18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(158,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_decrement.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_decrement.bpl(142,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_decrement.bpl(158,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(155,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(137,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(152,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(158,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(138,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(155,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(149,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(130,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(145,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 13:13 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_transfer_transfer.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_transfer_transfer.bpl(131,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_transfer_transfer.bpl(149,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 13:14 INFO    : ************ counter ***************
18-02-01 13:14 INFO    : Checking the syntax
18-02-01 13:14 INFO    : Parsing the specification
18-02-01 13:14 INFO    : Checking the well-formedness of the specification
18-02-01 13:14 INFO    : Checking convergence
18-02-01 13:14 INFO    : Checking safety
18-02-01 13:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(167,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(145,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(163,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(159,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(159,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(149,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 13:16 INFO    : ************ counter ***************
18-02-01 13:16 INFO    : Checking the syntax
18-02-01 13:16 INFO    : Parsing the specification
18-02-01 13:16 INFO    : Checking the well-formedness of the specification
18-02-01 13:16 INFO    : Checking convergence
18-02-01 13:16 INFO    : Checking safety
18-02-01 13:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(167,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(145,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(163,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(159,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(159,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 13:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(149,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 15:27 INFO    : ************ counter ***************
18-02-01 15:27 INFO    : Checking the syntax
18-02-01 15:27 INFO    : Parsing the specification
18-02-01 15:27 INFO    : Checking the well-formedness of the specification
18-02-01 15:27 INFO    : Checking convergence
18-02-01 15:27 INFO    : Checking safety
18-02-01 15:27 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(167,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(145,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(163,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 15:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(159,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 15:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(159,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 15:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(149,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 16:00 INFO    : ************ counter ***************
18-02-01 16:00 INFO    : Checking the syntax
18-02-01 16:00 INFO    : Parsing the specification
18-02-01 16:00 INFO    : Checking the well-formedness of the specification
18-02-01 16:00 INFO    : Checking convergence
18-02-01 16:00 INFO    : Checking safety
18-02-01 16:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_transfer.bpl(167,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_transfer.bpl(145,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_transfer.bpl(163,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 16:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_decrement.bpl(159,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_decrement.bpl(140,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_decrement.bpl(156,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 16:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_merge_transfer.bpl(162,1): Error BP5002: A precondition for this call might not hold.
results/stability_merge_transfer.bpl(141,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_merge_transfer.bpl(159,2): anon0

Boogie program verifier finished with 2 verified, 1 error

18-02-01 16:00 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_decrement_decrement.bpl(153,1): Error BP5002: A precondition for this call might not hold.
results/stability_decrement_decrement.bpl(133,1): Related location: This is the precondition that might not hold.
Execution trace:
    results/stability_decrement_decrement.bpl(149,2): anon0

Boogie program verifier finished with 1 verified, 1 error

18-02-01 16:06 INFO    : ************ sample ***************
18-02-01 16:06 INFO    : Checking the syntax
18-02-01 16:06 INFO    : Parsing the specification
18-02-01 16:06 INFO    : Checking the well-formedness of the specification
18-02-01 16:06 INFO    : Checking convergence
18-02-01 16:06 INFO    : Checking safety
18-02-01 16:06 INFO    : The specification is safe!!!
18-02-01 22:49 INFO    : ************ sample ***************
18-02-01 22:49 INFO    : Checking the syntax
18-02-01 22:49 INFO    : Parsing the specification
18-02-01 22:49 INFO    : Checking the well-formedness of the specification
18-02-01 22:49 INFO    : Checking convergence
18-02-01 22:49 INFO    : Checking safety
18-02-01 22:49 INFO    : The specification is safe!!!
18-02-01 22:49 INFO    : ************ counter ***************
18-02-01 22:49 INFO    : Checking the syntax
18-02-01 22:49 INFO    : Parsing the specification
18-02-01 22:49 INFO    : Checking the well-formedness of the specification
18-02-01 22:49 INFO    : Checking convergence
18-02-01 22:49 INFO    : Checking safety
18-02-01 22:49 ERROR   : A precondition for this call might not hold.
o
This is the precondition that might not hold.
a
The value of parameters and variables are ::
_n0 -> 1188
_n1 -> 6270
_from1 -> 88
_to1 -> 87
_id0 -> 88
18-02-01 22:49 ERROR   : A precondition for this call might not hold.

This is the precondition that might not hold.
e
The value of parameters and variables are ::
_n1 -> 719
_newR0 -> |T@[Int][Int]Int!val!1|
_newU0 -> |T@[Int]Int!val!1|
_id1 -> 9
18-02-01 22:49 ERROR   : A precondition for this call might not hold.
;
This is the precondition that might not hold.
p
The value of parameters and variables are ::
_newR0 -> |T@[Int][Int]Int!val!1|
_to1 -> 50
_newU0 -> |T@[Int]Int!val!1|
_n1 -> 2085
_from1 -> 51
18-02-01 22:49 ERROR   : A precondition for this call might not hold.
[
This is the precondition that might not hold.
&
The value of parameters and variables are ::
_n0 -> 1689
_n1 -> 2460
_id0 -> 88
_id1 -> 88
18-02-01 22:51 INFO    : ************ counter ***************
18-02-01 22:51 INFO    : Checking the syntax
18-02-01 22:51 INFO    : Parsing the specification
18-02-01 22:51 INFO    : Checking the well-formedness of the specification
18-02-01 22:51 INFO    : Checking convergence
18-02-01 22:51 INFO    : Checking safety
18-02-01 22:51 ERROR   : list index out of range
18-02-01 22:51 ERROR   : list index out of range
18-02-01 22:51 ERROR   : list index out of range
18-02-01 22:51 ERROR   : list index out of range
18-02-01 22:56 INFO    : ************ counter ***************
18-02-01 22:56 INFO    : Checking the syntax
18-02-01 22:56 INFO    : Parsing the specification
18-02-01 22:56 INFO    : Checking the well-formedness of the specification
18-02-01 22:56 INFO    : Checking convergence
18-02-01 22:56 INFO    : Checking safety
18-02-01 22:56 ERROR   : A precondition for this call might not hold.
o
This is the precondition that might not hold.
a
The value of parameters and variables are ::
_id0 -> 88
_n0 -> 1188
_n1 -> 6270
_to1 -> 87
_from1 -> 88
18-02-01 22:56 ERROR   : A precondition for this call might not hold.

This is the precondition that might not hold.
e
The value of parameters and variables are ::
_id1 -> 9
_newU0 -> |T@[Int]Int!val!1|
_n1 -> 719
_newR0 -> |T@[Int][Int]Int!val!1|
18-02-01 22:56 ERROR   : A precondition for this call might not hold.
;
This is the precondition that might not hold.
p
The value of parameters and variables are ::
_newR0 -> |T@[Int][Int]Int!val!1|
_from1 -> 51
_newU0 -> |T@[Int]Int!val!1|
_n1 -> 2085
_to1 -> 50
18-02-01 22:56 ERROR   : A precondition for this call might not hold.
[
This is the precondition that might not hold.
&
The value of parameters and variables are ::
_id0 -> 88
_id1 -> 88
_n0 -> 1689
_n1 -> 2460
18-02-01 22:57 INFO    : ************ counter ***************
18-02-01 22:57 INFO    : Checking the syntax
18-02-01 22:57 INFO    : Parsing the specification
18-02-01 22:57 INFO    : Checking the well-formedness of the specification
18-02-01 22:57 INFO    : Checking convergence
18-02-01 22:57 INFO    : Checking safety
18-02-01 22:58 ERROR   : A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_to1 -> 87
_from1 -> 88
_n0 -> 1188
_n1 -> 6270
_id0 -> 88
18-02-01 22:58 ERROR   : A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_n1 -> 719
_newR0 -> |T@[Int][Int]Int!val!1|
_newU0 -> |T@[Int]Int!val!1|
_id1 -> 9
18-02-01 22:58 ERROR   : A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_to1 -> 50
_newU0 -> |T@[Int]Int!val!1|
_from1 -> 51
_newR0 -> |T@[Int][Int]Int!val!1|
_n1 -> 2085
18-02-01 22:58 ERROR   : A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_n0 -> 1689
_n1 -> 2460
_id0 -> 88
_id1 -> 88
18-02-01 22:59 INFO    : ************ counter ***************
18-02-01 22:59 INFO    : Checking the syntax
18-02-01 22:59 INFO    : Parsing the specification
18-02-01 22:59 INFO    : Checking the well-formedness of the specification
18-02-01 22:59 INFO    : Checking convergence
18-02-01 22:59 INFO    : Checking safety
18-02-01 22:59 ERROR   : stability_decrement_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_n0 -> 1188
_n1 -> 6270
_to1 -> 87
_from1 -> 88
18-02-01 22:59 ERROR   : stability_merge_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id1 -> 9
_newU0 -> |T@[Int]Int!val!1|
_n1 -> 719
_newR0 -> |T@[Int][Int]Int!val!1|
18-02-01 22:59 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_newU0 -> |T@[Int]Int!val!1|
_from1 -> 51
_newR0 -> |T@[Int][Int]Int!val!1|
_n1 -> 2085
_to1 -> 50
18-02-01 22:59 ERROR   : stability_decrement_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_id1 -> 88
_n0 -> 1689
_n1 -> 2460
18-02-02 09:12 INFO    : ************ sample ***************
18-02-02 09:12 INFO    : Checking the syntax
18-02-02 09:12 INFO    : Parsing the specification
18-02-02 09:12 INFO    : Checking the well-formedness of the specification
18-02-02 09:12 INFO    : Checking convergence
18-02-02 09:12 INFO    : Checking safety
18-02-02 09:12 INFO    : The specification is safe!!!
18-02-02 09:14 INFO    : ************ counter ***************
18-02-02 09:14 INFO    : Checking the syntax
18-02-02 09:14 INFO    : Parsing the specification
18-02-02 09:14 INFO    : Checking the well-formedness of the specification
18-02-02 09:14 INFO    : Checking convergence
18-02-02 09:14 INFO    : Checking safety
18-02-02 09:14 ERROR   : stability_decrement_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_from1 -> 88
_n0 -> 1188
_n1 -> 6270
_id0 -> 88
_to1 -> 87
18-02-02 09:14 ERROR   : stability_merge_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_newU0 -> |T@[Int]Int!val!1|
_newR0 -> |T@[Int][Int]Int!val!1|
_id1 -> 9
_n1 -> 719
18-02-02 09:14 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_from1 -> 51
_newU0 -> |T@[Int]Int!val!1|
_newR0 -> |T@[Int][Int]Int!val!1|
_to1 -> 50
_n1 -> 2085
18-02-02 09:14 ERROR   : stability_decrement_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_n0 -> 1689
_n1 -> 2460
_id0 -> 88
_id1 -> 88
18-02-02 09:20 INFO    : ************ counter ***************
18-02-02 09:20 INFO    : Checking the syntax
18-02-02 09:20 INFO    : Parsing the specification
18-02-02 09:20 INFO    : Checking the well-formedness of the specification
18-02-02 09:20 INFO    : Checking convergence
18-02-02 09:20 INFO    : Checking safety
18-02-02 09:20 ERROR   : stability_decrement_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_from1 -> 88
_to1 -> 87
_n0 -> 1188
_n1 -> 6270
18-02-02 09:20 ERROR   : stability_merge_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id1 -> 9
_newR0 -> |T@[Int][Int]Int!val!1|
_n1 -> 719
_newU0 -> |T@[Int]Int!val!1|
18-02-02 09:20 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_newU0 -> |T@[Int]Int!val!1|
_from1 -> 51
_to1 -> 50
_n1 -> 2085
_newR0 -> |T@[Int][Int]Int!val!1|
18-02-02 09:20 ERROR   : stability_decrement_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_id1 -> 88
_n0 -> 1689
_n1 -> 2460
18-02-02 09:20 INFO    : ************ sample ***************
18-02-02 09:20 INFO    : Checking the syntax
18-02-02 09:20 INFO    : Parsing the specification
18-02-02 09:20 INFO    : Checking the well-formedness of the specification
18-02-02 09:20 INFO    : Checking convergence
18-02-02 09:20 INFO    : Checking safety
18-02-02 09:20 INFO    : The specification is safe!!!
18-02-02 12:24 INFO    : ************ sample ***************
18-02-02 12:24 INFO    : Checking the syntax
18-02-02 12:24 INFO    : Parsing the specification
18-02-02 12:24 INFO    : Checking the well-formedness of the specification
18-02-02 12:24 INFO    : Checking convergence
18-02-02 12:24 INFO    : Checking safety
18-02-02 12:24 INFO    : The specification is safe!!!
18-02-02 12:25 INFO    : ************ sample ***************
18-02-02 12:25 INFO    : Checking the syntax
18-02-02 12:25 INFO    : Parsing the specification
18-02-02 12:25 INFO    : Checking the well-formedness of the specification
18-02-02 12:25 INFO    : Checking convergence
18-02-02 12:25 INFO    : Checking safety
18-02-02 12:25 INFO    : ************ counter ***************
18-02-02 12:25 INFO    : Checking the syntax
18-02-02 12:25 INFO    : Parsing the specification
18-02-02 12:25 INFO    : Checking the well-formedness of the specification
18-02-02 12:25 INFO    : Checking convergence
18-02-02 12:25 INFO    : Checking safety
18-02-02 12:25 ERROR   : stability_decrement_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_from1 -> 88
_to1 -> 87
_n0 -> 1188
_n1 -> 6270
18-02-02 12:25 ERROR   : stability_merge_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id1 -> 9
_n1 -> 719
_newR0 -> |T@[Int][Int]Int!val!1|
_newU0 -> |T@[Int]Int!val!1|
18-02-02 12:25 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1,_n1);
This is the precondition that might not hold.
requires (local_rights(from, R, U) >= n);
The value of parameters and variables are ::
_from1 -> 51
_n1 -> 2085
_to1 -> 50
_newR0 -> |T@[Int][Int]Int!val!1|
_newU0 -> |T@[Int]Int!val!1|
18-02-02 12:25 ERROR   : stability_decrement_decrement::::::
A precondition for this call might not hold.
call decrement(_id1,_n1);
This is the precondition that might not hold.
requires (local_rights(id, R, U) >= n);
The value of parameters and variables are ::
_id0 -> 88
_id1 -> 88
_n0 -> 1689
_n1 -> 2460
18-02-06 16:35 INFO    : ************ book_store ***************
18-02-06 16:35 INFO    : Checking the syntax
18-02-06 16:35 INFO    : Parsing the specification
18-02-06 16:35 INFO    : Checking the well-formedness of the specification
18-02-06 16:35 INFO    : Checking convergence
18-02-06 16:35 INFO    : Checking safety
18-02-06 16:35 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty0 -> 0
18-02-06 16:35 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty1 -> 142
18-02-06 16:35 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
18-02-06 16:36 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!11
_usr1 -> T@U!val!14
18-02-06 16:36 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_qty1 -> 853
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!11
_incoming0 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
18-02-06 16:36 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11
18-02-21 10:46 INFO    : ************ book_store ***************
18-02-21 10:46 INFO    : Checking the syntax
18-02-21 10:46 INFO    : Parsing the specification
18-02-21 10:46 INFO    : Checking the well-formedness of the specification
18-02-21 10:46 INFO    : Checking convergence
18-02-21 10:47 INFO    : Checking safety
18-02-21 10:47 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!17
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
18-02-21 10:47 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
18-02-21 10:47 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
18-02-21 10:47 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
18-02-21 10:47 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
18-02-21 10:47 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
_qty1 -> 853
usr -> T@U!val!10
_usr1 -> T@U!val!13
18-02-21 10:47 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
18-02-21 10:47 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
18-02-21 10:47 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!11
_incoming0 -> T@U!val!13
18-02-21 10:47 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
18-02-21 10:47 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
18-02-21 10:47 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11
18-02-21 10:47 ERROR   : name 'TokenGenerator' is not defined

18-02-21 10:49 INFO    : ************ book_store ***************
18-02-21 10:49 INFO    : Checking the syntax
18-02-21 10:49 INFO    : Parsing the specification
18-02-21 10:49 INFO    : Checking the well-formedness of the specification
18-02-21 10:49 INFO    : Checking convergence
18-02-21 10:49 INFO    : Checking safety
18-02-21 10:49 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_qty0 -> 0
_book0 -> T@U!val!17
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15

18-02-21 10:49 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15

18-02-21 10:49 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14

18-02-21 10:49 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!11
_usr1 -> T@U!val!14

18-02-21 10:49 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:49 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
_qty1 -> 853

18-02-21 10:49 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:49 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:50 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!11
_incoming0 -> T@U!val!13

18-02-21 10:50 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13

18-02-21 10:50 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13

18-02-21 10:50 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-21 10:50 ERROR   : must be str, not Procedure

18-02-21 10:51 INFO    : ************ book_store ***************
18-02-21 10:51 INFO    : Checking the syntax
18-02-21 10:51 INFO    : Parsing the specification
18-02-21 10:51 INFO    : Checking the well-formedness of the specification
18-02-21 10:51 INFO    : Checking convergence
18-02-21 10:51 INFO    : Checking safety
18-02-21 10:52 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty0 -> 0
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_book0 -> T@U!val!17

18-02-21 10:52 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty1 -> 142
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-21 10:52 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:52 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:52 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:52 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_qty1 -> 853
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13

18-02-21 10:52 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:52 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:52 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!11

18-02-21 10:52 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:52 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:52 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-21 10:53 INFO    : ************ book_store ***************
18-02-21 10:53 INFO    : Checking the syntax
18-02-21 10:53 INFO    : Parsing the specification
18-02-21 10:53 INFO    : Checking the well-formedness of the specification
18-02-21 10:53 INFO    : Checking convergence
18-02-21 10:53 INFO    : Checking safety
18-02-21 10:53 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty0 -> 0
_book0 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-21 10:53 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
_qty1 -> 142
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-21 10:53 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:54 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:54 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15

18-02-21 10:54 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_qty1 -> 853
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15

18-02-21 10:54 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15

18-02-21 10:54 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15

18-02-21 10:54 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!11
_incoming0 -> T@U!val!13

18-02-21 10:54 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:54 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:54 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-21 10:54 INFO    : The possible token for ensuring stability of updateOrder and placeOrder ::
18-02-21 10:54 INFO    : ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:54 INFO    : The possible token for ensuring stability of placeOrder and updateOrder ::
18-02-21 10:54 INFO    : ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:54 INFO    : The possible token for ensuring stability of cancelOrder and processOrder ::
18-02-21 10:54 INFO    : ['_id0 != _id1']
18-02-21 10:54 INFO    : The possible token for ensuring stability of processOrder and cancelOrder ::
18-02-21 10:54 INFO    : ['_id0 != _id1']
18-02-21 10:54 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-21 10:54 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-21 10:54 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-21 10:54 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-21 10:54 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-21 10:54 INFO    : The possible token for ensuring stability of createOrder and createOrder ::
18-02-21 10:54 INFO    : ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:54 INFO    : The possible token for ensuring stability of placeOrder and placeOrder ::
18-02-21 10:54 INFO    : ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:54 INFO    : The possible token for ensuring stability of processOrder and processOrder ::
18-02-21 10:54 INFO    : ['_id0 != _id1']
18-02-21 10:57 INFO    : ************ book_store ***************
18-02-21 10:57 INFO    : Checking the syntax
18-02-21 10:57 INFO    : Parsing the specification
18-02-21 10:57 INFO    : Checking the well-formedness of the specification
18-02-21 10:57 INFO    : Checking convergence
18-02-21 10:57 INFO    : Checking safety
18-02-21 10:58 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
_book0 -> T@U!val!17
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-21 10:58 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-21 10:58 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:58 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:58 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:58 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 853
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13

18-02-21 10:58 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:58 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-21 10:58 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!11

18-02-21 10:58 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:58 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:58 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-21 10:58 ERROR   : must be str, not list

18-02-21 10:58 INFO    : ************ book_store ***************
18-02-21 10:58 INFO    : Checking the syntax
18-02-21 10:58 INFO    : Parsing the specification
18-02-21 10:58 INFO    : Checking the well-formedness of the specification
18-02-21 10:58 INFO    : Checking convergence
18-02-21 10:58 INFO    : Checking safety
18-02-21 10:59 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_book0 -> T@U!val!17
_qty0 -> 0

18-02-21 10:59 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_qty1 -> 142

18-02-21 10:59 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:59 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-21 10:59 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:59 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_qty1 -> 853

18-02-21 10:59 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:59 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15

18-02-21 10:59 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!11
_incoming0 -> T@U!val!13

18-02-21 10:59 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:59 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-21 10:59 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']
18-02-21 10:59 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-21 10:59 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-21 10:59 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-21 10:59 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-21 10:59 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']
18-02-21 10:59 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']
18-02-23 08:58 INFO    : ************ book_store ***************
18-02-23 08:58 INFO    : Checking the syntax
18-02-23 08:58 INFO    : Parsing the specification
18-02-23 08:58 INFO    : Checking the well-formedness of the specification
18-02-23 08:58 INFO    : Checking convergence
18-02-23 08:58 INFO    : Checking safety
18-02-23 08:58 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
_book0 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15

18-02-23 08:58 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15

18-02-23 08:58 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14

18-02-23 08:58 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!11
_usr1 -> T@U!val!14

18-02-23 08:58 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13

18-02-23 08:58 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!15
usr -> T@U!val!10
_usr1 -> T@U!val!13
_qty1 -> 853

18-02-23 08:58 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13

18-02-23 08:58 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr1 -> T@U!val!13

18-02-23 08:58 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!11

18-02-23 08:58 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13

18-02-23 08:58 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13

18-02-23 08:58 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-23 08:58 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 08:58 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 08:58 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-23 08:58 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-23 08:58 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-23 08:58 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-23 08:58 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-23 08:58 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-23 08:58 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-23 08:58 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 08:59 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 08:59 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-23 15:37 INFO    : ************ book_store ***************
18-02-23 15:37 INFO    : Checking the syntax
18-02-23 15:37 INFO    : Parsing the specification
18-02-23 15:37 INFO    : Checking the well-formedness of the specification
18-02-23 15:37 INFO    : Checking convergence
18-02-23 15:37 INFO    : Checking safety
18-02-23 15:37 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_book0 -> T@U!val!17

18-02-23 15:37 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!15
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-23 15:37 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 15:37 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 15:37 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-23 15:37 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_qty1 -> 853
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15

18-02-23 15:37 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-23 15:37 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!13
_incoming0 -> T@U!val!15
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-23 15:37 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!13
id -> T@U!val!9
_id1 -> T@U!val!11

18-02-23 15:37 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-23 15:37 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!13
_usr1 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-23 15:37 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!11
_id1 -> T@U!val!11

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-23 15:37 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-23 15:37 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-23 15:37 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-23 15:37 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-23 15:37 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 15:37 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-23 15:38 INFO    : ************ book_store_complete ***************
18-02-23 15:38 INFO    : Checking the syntax
18-02-23 15:38 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(61,55): error: invalid Function
1 parse errors detected in results/book_store_complete.bpl



18-02-23 15:39 INFO    : ************ book_store_complete ***************
18-02-23 15:39 INFO    : Checking the syntax
18-02-23 15:39 INFO    : Parsing the specification
18-02-23 15:39 INFO    : Checking the well-formedness of the specification
18-02-23 15:39 INFO    : Checking convergence
18-02-23 15:39 INFO    : Checking safety
18-02-23 15:39 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
_book0 -> T@U!val!18

18-02-23 15:39 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-23 15:39 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15

18-02-23 15:39 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!11
_usr1 -> T@U!val!15

18-02-23 15:40 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-23 15:40 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
_qty1 -> 853

18-02-23 15:40 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-23 15:40 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-23 15:40 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-23 15:40 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-23 15:40 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-23 15:40 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-23 15:40 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-23 15:40 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-23 15:40 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-23 15:40 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-23 15:40 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-23 15:40 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-23 16:22 INFO    : ************ book_store_complete ***************
18-02-23 16:22 INFO    : Checking the syntax
18-02-23 16:22 INFO    : Parsing the specification
18-02-23 16:22 INFO    : Checking the well-formedness of the specification
18-02-23 16:22 INFO    : Checking convergence
18-02-23 16:22 INFO    : Checking safety
18-02-23 16:22 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_book0 -> T@U!val!18

18-02-23 16:22 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-02-23 16:22 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
_qty1 -> 853
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-23 16:22 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 16:23 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 16:23 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-23 16:23 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-23 16:23 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-23 16:23 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-23 16:23 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-23 16:23 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 16:23 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-23 17:56 INFO    : ************ book_store_complete ***************
18-02-23 17:56 INFO    : Checking the syntax
18-02-23 17:56 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(22,3): error: EOF expected
1 parse errors detected in results/book_store_complete.bpl



18-02-23 17:56 INFO    : ************ book_store_complete ***************
18-02-23 17:56 INFO    : Checking the syntax
18-02-23 17:56 INFO    : Parsing the specification
18-02-23 17:56 INFO    : Checking the well-formedness of the specification
18-02-23 17:56 INFO    : Checking convergence
18-02-23 17:56 INFO    : Checking safety
18-02-23 17:56 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
_book0 -> T@U!val!18
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-02-23 17:56 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 142
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-02-23 17:56 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-23 17:56 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-23 17:57 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-23 17:57 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_qty1 -> 853
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-23 17:57 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-23 17:57 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-23 17:57 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-23 17:57 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 17:57 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-23 17:57 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-23 17:57 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-23 17:57 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-23 17:57 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-23 17:57 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-23 17:57 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-23 17:57 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-26 14:52 INFO    : ************ book_store_complete ***************
18-02-26 14:52 INFO    : Checking the syntax
18-02-26 14:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(54,82): error: invalid UnaryExpression
1 parse errors detected in results/book_store_complete.bpl



18-02-26 14:53 INFO    : ************ book_store_complete ***************
18-02-26 14:53 INFO    : Checking the syntax
18-02-26 14:53 INFO    : Parsing the specification
18-02-26 14:53 INFO    : Checking the well-formedness of the specification
18-02-26 14:53 INFO    : Checking convergence
18-02-26 14:53 INFO    : Checking safety
18-02-26 14:53 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!18
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-26 14:53 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty1 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-26 14:53 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15

18-02-26 14:53 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_storeloc0 -> T@U!val!16
usr -> T@U!val!11
_usr1 -> T@U!val!15

18-02-26 14:54 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-26 14:54 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_qty1 -> 0
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-26 14:54 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-26 14:54 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-26 14:54 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-26 14:54 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-26 14:54 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-26 14:54 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
_storeloc0 -> T@U!val!13

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-26 14:54 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-26 14:54 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-26 14:54 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-26 14:54 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-26 14:54 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-26 14:54 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-26 15:45 INFO    : ************ book_store_complete ***************
18-02-26 15:45 INFO    : Checking the syntax
18-02-26 15:45 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(82,12): Error: undeclared type: Orderid
1 name resolution errors detected in results/book_store_complete.bpl


18-02-26 15:46 INFO    : ************ book_store_complete ***************
18-02-26 15:46 INFO    : Checking the syntax
18-02-26 15:46 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(82,62): Error: invalid argument types ([ISBN]int and int) to binary operator >
results/book_store_complete.bpl(86,114): Error: invalid argument types ([ISBN]int and int) to binary operator >
2 type checking errors detected in results/book_store_complete.bpl



18-02-26 15:46 INFO    : ************ book_store_complete ***************
18-02-26 15:46 INFO    : Checking the syntax
18-02-26 15:46 INFO    : Parsing the specification
18-02-26 15:46 INFO    : Checking the well-formedness of the specification
18-02-26 15:46 INFO    : Checking convergence
18-02-26 15:46 INFO    : Checking safety
18-02-26 15:46 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!18
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty0 -> 0

18-02-26 15:47 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty1 -> 0

18-02-26 15:47 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-26 15:47 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_storeloc0 -> T@U!val!16
usr -> T@U!val!11
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-26 15:47 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-26 15:47 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
_qty1 -> 0
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-26 15:47 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-26 15:47 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-26 15:47 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!12

18-02-26 15:47 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-26 15:47 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-26 15:47 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
_storeloc0 -> T@U!val!13
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-26 15:47 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-26 15:47 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-26 15:47 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-26 15:47 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-26 15:47 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-26 15:47 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:27 INFO    : ************ book_store_complete ***************
18-02-27 11:27 INFO    : Checking the syntax
18-02-27 11:27 INFO    : Parsing the specification
18-02-27 11:27 INFO    : Checking the well-formedness of the specification
18-02-27 11:27 INFO    : Checking convergence
18-02-27 11:27 INFO    : Checking safety
18-02-27 11:27 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_book0 -> T@U!val!18
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
_qty0 -> 0

18-02-27 11:27 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
_qty1 -> 0

18-02-27 11:27 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
usr -> T@U!val!10
_usr0 -> T@U!val!15

18-02-27 11:27 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_storeloc0 -> T@U!val!16
usr -> T@U!val!11
_usr1 -> T@U!val!15

18-02-27 11:28 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-27 11:28 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 11:28 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-27 11:28 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-02-27 11:28 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-27 11:28 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-27 11:28 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-27 11:28 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
_storeloc0 -> T@U!val!13

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-27 11:28 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-27 11:28 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-27 11:28 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-27 11:28 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-27 11:28 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:28 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:31 INFO    : ************ book_store_complete ***************
18-02-27 11:31 INFO    : Checking the syntax
18-02-27 11:31 INFO    : Parsing the specification
18-02-27 11:31 INFO    : Checking the well-formedness of the specification
18-02-27 11:31 INFO    : Checking convergence
18-02-27 11:31 INFO    : Checking safety
18-02-27 11:31 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_book0 -> T@U!val!18
_qty0 -> 0

18-02-27 11:31 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty1 -> 0

18-02-27 11:31 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14

18-02-27 11:32 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!11
_usr1 -> T@U!val!15
id -> T@U!val!9
_id0 -> T@U!val!14
_id1 -> T@U!val!14
_storeloc0 -> T@U!val!16

18-02-27 11:32 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-02-27 11:32 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
_qty1 -> 0

18-02-27 11:32 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-02-27 11:32 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-02-27 11:32 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-27 11:32 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!14
user -> T@U!val!2
_user1 -> T@U!val!12

18-02-27 11:32 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-27 11:32 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-02-27 11:32 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!12
_id1 -> T@U!val!12
_storeloc0 -> T@U!val!13

18-02-27 11:32 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-27 11:32 INFO    : Not able to determine a token for the stability of mergeUsers and registerUser
18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:32 INFO    : The possible token(s) for ensuring stability of registerUser and registerUser ::
['_user0 != _user1']

18-02-27 11:40 INFO    : ************ book_store_complete ***************
18-02-27 11:40 INFO    : Checking the syntax
18-02-27 11:40 INFO    : Parsing the specification
18-02-27 11:40 INFO    : Checking the well-formedness of the specification
18-02-27 11:40 INFO    : Checking convergence
18-02-27 11:41 INFO    : Checking safety
18-02-27 11:41 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
_book0 -> T@U!val!18
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-27 11:41 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-27 11:41 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
storeloc -> T@U!val!13
_storeloc1 -> T@U!val!17

18-02-27 11:41 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!13
_usr1 -> T@U!val!17
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!16

18-02-27 11:41 ERROR   : stability_mergeStore_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14

18-02-27 11:41 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 11:41 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
_qty1 -> 0
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-27 11:41 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 11:41 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 11:41 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14

18-02-27 11:42 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-27 11:42 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-27 11:42 ERROR   : stability_placeOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == false && (exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-27 11:42 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!15
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14

18-02-27 11:42 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeStore and processOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-27 11:42 INFO    : Not able to determine a token for the stability of mergeUsers and registerUser
18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of placeOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1 && _storeloc0 != _storeloc1']

18-02-27 11:42 INFO    : The possible token(s) for ensuring stability of registerUser and registerUser ::
['_user0 != _user1']

18-02-27 15:11 INFO    : ************ book_store_complete ***************
18-02-27 15:11 INFO    : Checking the syntax
18-02-27 15:11 INFO    : Parsing the specification
18-02-27 15:11 INFO    : Checking the well-formedness of the specification
18-02-27 15:11 INFO    : Checking convergence
18-02-27 15:11 INFO    : Checking safety
18-02-27 15:12 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty0 -> 0
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_book0 -> T@U!val!18
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-27 15:12 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-02-27 15:12 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
storeloc -> T@U!val!13
_storeloc1 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16

18-02-27 15:12 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!13
_usr1 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!16

18-02-27 15:12 ERROR   : stability_mergeStore_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
usr -> T@U!val!10
_usr1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-02-27 15:12 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-02-27 15:12 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-02-27 15:13 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!15
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14

18-02-27 15:13 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeStore and processOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-02-27 15:13 INFO    : Not able to determine a token for the stability of mergeUsers and registerUser
18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_id0 != _id1 && _storeloc0 != _storeloc1']

18-02-27 15:13 INFO    : The possible token(s) for ensuring stability of registerUser and registerUser ::
['_user0 != _user1']

18-03-06 10:36 INFO    : ************ book_store_complete ***************
18-03-06 10:36 INFO    : Checking the syntax
18-03-06 10:36 INFO    : Parsing the specification
18-03-06 10:36 INFO    : Checking the well-formedness of the specification
18-03-06 10:36 INFO    : Checking convergence
18-03-06 10:36 INFO    : Checking safety
18-03-06 10:36 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!18
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-03-06 10:36 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty1 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16

18-03-06 10:36 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
storeloc -> T@U!val!13
_storeloc1 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!10
_usr0 -> T@U!val!16

18-03-06 10:36 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
usr -> T@U!val!13
_usr1 -> T@U!val!17

18-03-06 10:37 ERROR   : stability_mergeStore_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-06 10:37 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-03-06 10:37 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
_qty1 -> 0
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-06 10:37 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-03-06 10:37 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-03-06 10:37 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-06 10:37 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!14
user -> T@U!val!2
_user1 -> T@U!val!12

18-03-06 10:37 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14

18-03-06 10:37 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!15

18-03-06 10:37 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of updateOrder and placeOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of placeOrder and updateOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of cancelOrder and processOrder ::
['_id0 != _id1']

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of processOrder and cancelOrder ::
['_id0 != _id1']

18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeStore and processOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeOrders and createOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeOrders and updateOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeOrders and placeOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeOrders and cancelOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeOrders and processOrder
18-03-06 10:37 INFO    : Not able to determine a token for the stability of mergeUsers and registerUser
18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of createOrder and createOrder ::
['_id0 != _id1', '_usr0 != _usr1', '_id0 != _id1 && _usr0 != _usr1']

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of processOrder and processOrder ::
['_storeloc0 != _storeloc1 && _id0 != _id1']

18-03-06 10:37 INFO    : The possible token(s) for ensuring stability of registerUser and registerUser ::
['_user0 != _user1']

18-03-06 12:40 INFO    : ************ book_store_complete ***************
18-03-06 12:40 INFO    : Checking the syntax
18-03-06 12:40 INFO    : Parsing the specification
18-03-06 12:40 INFO    : Checking the well-formedness of the specification
18-03-06 12:40 INFO    : Checking convergence
18-03-06 12:40 INFO    : Checking safety
18-03-06 12:40 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_book0 -> T@U!val!18
_qty0 -> 0

18-03-06 12:40 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
_qty1 -> 0

18-03-06 12:41 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
storeloc -> T@U!val!13
_storeloc1 -> T@U!val!17

18-03-06 12:41 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!13
_usr1 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeStore_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-06 12:41 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16
id -> T@U!val!9
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
_incoming0 -> T@U!val!16

18-03-06 12:41 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user1 -> T@U!val!12
_incoming0 -> T@U!val!14

18-03-06 12:41 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-03-06 12:41 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!15
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14

18-03-06 12:41 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-03-06 12:42 INFO    : The tokens are as follows ::
placeOrder:
mergeOrders should be executed while acquiring the token.
Token shared with updateOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

updateOrder:
mergeOrders should be executed while acquiring the token.
Token shared with placeOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

processOrder:
mergeStore and mergeOrders should be executed while acquiring the token.
Token shared with cancelOrder on ['_id0 != _id1'] and processOrder on ['_id0 != _id1 && _storeloc0 != _storeloc1']

cancelOrder:
mergeOrders should be executed while acquiring the token.
Token shared with processOrder on ['_id0 != _id1']

createOrder:
mergeOrders should be executed while acquiring the token.
Token shared with createOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

registerUser:
mergeUsers should be executed while acquiring the token.
Token shared with registerUser on ['_user0 != _user1']

18-03-14 15:03 INFO    : ************ book_store_complete ***************
18-03-14 15:03 INFO    : Checking the syntax
18-03-14 15:03 INFO    : Parsing the specification
18-03-14 15:03 INFO    : Checking the well-formedness of the specification
18-03-14 15:03 INFO    : Checking convergence
18-03-14 15:03 INFO    : Checking safety
18-03-14 15:04 ERROR   : stability_updateOrder_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_book0 -> T@U!val!18
_qty0 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-03-14 15:04 ERROR   : stability_placeOrder_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_qty1 -> 0
usr -> T@U!val!10
_usr0 -> T@U!val!16
_usr1 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-03-14 15:04 ERROR   : stability_cancelOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!16
storeloc -> T@U!val!13
_storeloc1 -> T@U!val!17
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-03-14 15:04 ERROR   : stability_processOrder_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!13
_usr1 -> T@U!val!17
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!16
id -> T@U!val!9
_id0 -> T@U!val!15
_id1 -> T@U!val!15

18-03-14 15:04 ERROR   : stability_mergeStore_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-14 15:04 ERROR   : stability_mergeOrders_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-14 15:04 ERROR   : stability_mergeOrders_updateOrder::::::
A precondition for this call might not hold.
call updateOrder(_id1,_usr1,_book1,_qty1);
This is the precondition that might not hold.
requires (qty >= 0 && UserOrders[id][created] == true && UserOrders[id][placed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
_qty1 -> 0
id -> T@U!val!9
_id1 -> T@U!val!13
usr -> T@U!val!10
_usr1 -> T@U!val!14

18-03-14 15:04 ERROR   : stability_mergeOrders_placeOrder::::::
A precondition for this call might not hold.
call placeOrder(_id1,_usr1);
This is the precondition that might not hold.
requires ((exists b:ISBN :: UserOrders[id][items][b] > 0) && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-14 15:04 ERROR   : stability_mergeOrders_cancelOrder::::::
A precondition for this call might not hold.
call cancelOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
usr -> T@U!val!10
_usr1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-14 15:04 ERROR   : stability_mergeOrders_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13
_incoming0 -> T@U!val!16
storeloc -> T@U!val!11
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id1 -> T@U!val!13

18-03-14 15:04 ERROR   : stability_mergeUsers_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
_incoming0 -> T@U!val!14
user -> T@U!val!2
_user1 -> T@U!val!12

18-03-14 15:04 ERROR   : stability_createOrder_createOrder::::::
A precondition for this call might not hold.
call createOrder(_id1,_usr1);
This is the precondition that might not hold.
requires (UserOrders[id][created] == false && UserOrders[id][user] == usr);
The value of parameters and variables are ::
usr -> T@U!val!10
_usr0 -> T@U!val!14
_usr1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13

18-03-14 15:05 ERROR   : stability_processOrder_processOrder::::::
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires (UserOrders[id][placed] == true && UserOrders[id][processed] == false && UserOrders[id][cancelled] == false);
A precondition for this call might not hold.
call processOrder(_id1,_storeloc1);
This is the precondition that might not hold.
requires ((forall b:ISBN :: BookStore[b][P][storeloc] - BookStore[b][N][storeloc] >= UserOrders[id][items][b]));
The value of parameters and variables are ::
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!13
storeloc -> T@U!val!11
_storeloc0 -> T@U!val!14
_storeloc1 -> T@U!val!14
id -> T@U!val!9
_id0 -> T@U!val!13
_id1 -> T@U!val!15

18-03-14 15:05 ERROR   : stability_registerUser_registerUser::::::
A precondition for this call might not hold.
call registerUser(_user1);
This is the precondition that might not hold.
requires (Users[user] == false);
The value of parameters and variables are ::
user -> T@U!val!2
_user0 -> T@U!val!11
_user1 -> T@U!val!11

18-03-14 15:05 INFO    : The tokens are as follows ::
placeOrder:
mergeOrders should be executed while acquiring the token.
Token shared with updateOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

updateOrder:
mergeOrders should be executed while acquiring the token.
Token shared with placeOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

processOrder:
mergeStore and mergeOrders should be executed while acquiring the token.
Token shared with cancelOrder on ['_id0 != _id1'] and processOrder on ['_storeloc0 != _storeloc1 && _id0 != _id1']

cancelOrder:
mergeOrders should be executed while acquiring the token.
Token shared with processOrder on ['_id0 != _id1']

createOrder:
mergeOrders should be executed while acquiring the token.
Token shared with createOrder on ['_usr0 != _usr1', '_id0 != _id1', '_usr0 != _usr1 && _id0 != _id1']

registerUser:
mergeUsers should be executed while acquiring the token.
Token shared with registerUser on ['_user0 != _user1']

18-03-15 12:41 INFO    : ************ token ***************
18-03-15 12:41 INFO    : Checking the syntax
18-03-15 12:41 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(5,41): error: "(" expected
results/token.bpl(11,51): error: "(" expected
results/token.bpl(25,46): error: ")" expected
3 parse errors detected in results/token.bpl



18-03-15 12:42 INFO    : ************ token ***************
18-03-15 12:42 INFO    : Checking the syntax
18-03-15 12:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(25,46): error: ")" expected
1 parse errors detected in results/token.bpl



18-03-15 12:42 INFO    : ************ token ***************
18-03-15 12:42 INFO    : Checking the syntax
18-03-15 12:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(32,8): error: "(" expected
results/token.bpl(32,15): error: ")" expected
2 parse errors detected in results/token.bpl



18-03-15 12:42 INFO    : ************ token ***************
18-03-15 12:42 INFO    : Checking the syntax
18-03-15 12:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(32,17): error: "{" expected
1 parse errors detected in results/token.bpl



18-03-15 12:43 INFO    : ************ token ***************
18-03-15 12:43 INFO    : Checking the syntax
18-03-15 12:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(13,34): Error: use of undeclared function: gt_eq
1 name resolution errors detected in results/token.bpl


18-03-15 12:43 INFO    : ************ token ***************
18-03-15 12:43 INFO    : Checking the syntax
18-03-15 12:43 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures t > old(t) && (forall r:int :: (r == to ==> V[r] == 1) && ( r != to ==> V[r] == 0));


18-03-15 12:44 INFO    : ************ token ***************
18-03-15 12:44 INFO    : Checking the syntax
18-03-15 12:44 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:int :: (r == to ==> V[r] == 1) && ( r != to ==> V[r] == 0));


18-03-15 12:45 INFO    : ************ token ***************
18-03-15 12:45 INFO    : Checking the syntax
18-03-15 12:45 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:int :: (r == to ==> V[r] == 1) && (r != to ==> V[r] == 0));


18-03-15 12:45 INFO    : ************ token ***************
18-03-15 12:45 INFO    : Checking the syntax
18-03-15 12:45 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures V[to] == 1; //(forall r:int :: (r == to ==> V[r] == 1) && (r != to ==> V[r] == 0));


18-03-15 12:46 INFO    : ************ token ***************
18-03-15 12:46 INFO    : Checking the syntax
18-03-15 12:46 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures V[to] == 1;


18-03-15 13:08 INFO    : ************ token ***************
18-03-15 13:08 INFO    : Checking the syntax
18-03-15 13:08 INFO    : Parsing the specification
18-03-15 13:08 INFO    : Checking the well-formedness of the specification
18-03-15 13:08 ERROR   : The function gteq_V should have return value of type bool

18-03-15 13:08 INFO    : ************ token ***************
18-03-15 13:08 INFO    : Checking the syntax
18-03-15 13:08 INFO    : Parsing the specification
18-03-15 13:08 INFO    : Checking the well-formedness of the specification
18-03-15 13:08 ERROR   : The return value must be bool

18-03-15 13:08 INFO    : ************ token ***************
18-03-15 13:08 INFO    : Checking the syntax
18-03-15 13:08 INFO    : Parsing the specification
18-03-15 13:08 INFO    : Checking the well-formedness of the specification
18-03-15 13:08 ERROR   : No merge procedures defined!

18-03-15 13:09 INFO    : ************ token ***************
18-03-15 13:09 INFO    : Checking the syntax
18-03-15 13:09 INFO    : Parsing the specification
18-03-15 13:09 INFO    : Checking the well-formedness of the specification
18-03-15 13:09 INFO    : Checking convergence
18-03-15 13:09 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(42,1): error: EOF expected
1 parse errors detected in results/monotonicity_transfer.bpl



18-03-15 15:19 INFO    : ************ token ***************
18-03-15 15:19 INFO    : Checking the syntax
18-03-15 15:19 INFO    : Parsing the specification
18-03-15 15:19 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:22 INFO    : ************ token ***************
18-03-15 15:22 INFO    : Checking the syntax
18-03-15 15:22 INFO    : Parsing the specification
18-03-15 15:22 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:22 INFO    : ************ token ***************
18-03-15 15:22 INFO    : Checking the syntax
18-03-15 15:22 INFO    : Parsing the specification
18-03-15 15:22 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:23 INFO    : ************ token ***************
18-03-15 15:23 INFO    : Checking the syntax
18-03-15 15:23 INFO    : Parsing the specification
18-03-15 15:23 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:24 INFO    : ************ token ***************
18-03-15 15:24 INFO    : Checking the syntax
18-03-15 15:24 INFO    : Parsing the specification
18-03-15 15:24 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:25 INFO    : ************ token ***************
18-03-15 15:25 INFO    : Checking the syntax
18-03-15 15:25 INFO    : Parsing the specification
18-03-15 15:25 ERROR   : unsupported operand type(s) for +: 'NoneType' and 'int'

18-03-15 15:26 INFO    : ************ token ***************
18-03-15 15:26 INFO    : Checking the syntax
18-03-15 15:26 INFO    : Parsing the specification
18-03-15 15:26 INFO    : Checking the well-formedness of the specification
18-03-15 15:26 INFO    : Checking convergence
18-03-15 15:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/lub_merge.bpl(62,1): error: "}" expected
1 parse errors detected in results/lub_merge.bpl



18-03-15 15:26 INFO    : ************ token ***************
18-03-15 15:26 INFO    : Checking the syntax
18-03-15 15:26 INFO    : Parsing the specification
18-03-15 15:26 INFO    : Checking the well-formedness of the specification
18-03-15 15:26 INFO    : Checking convergence
18-03-15 15:26 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/lub_merge.bpl(62,1): error: "}" expected
1 parse errors detected in results/lub_merge.bpl



18-03-15 15:30 INFO    : ************ token ***************
18-03-15 15:30 INFO    : Checking the syntax
18-03-15 15:30 INFO    : Parsing the specification
18-03-15 15:30 ERROR   : sequence item 0: expected str instance, int found

18-03-15 15:32 INFO    : ************ token ***************
18-03-15 15:32 INFO    : Checking the syntax
18-03-15 15:32 INFO    : Parsing the specification
18-03-15 15:32 ERROR   : name 'position' is not defined

18-03-15 15:32 INFO    : ************ token ***************
18-03-15 15:32 INFO    : Checking the syntax
18-03-15 15:32 INFO    : Parsing the specification
18-03-15 15:32 ERROR   : name 'position' is not defined

18-03-15 15:33 INFO    : ************ token ***************
18-03-15 15:33 INFO    : Checking the syntax
18-03-15 15:33 INFO    : Parsing the specification
18-03-15 15:33 ERROR   : name 'position' is not defined

18-03-15 15:33 INFO    : ************ token ***************
18-03-15 15:33 INFO    : Checking the syntax
18-03-15 15:33 INFO    : Parsing the specification
18-03-15 15:33 ERROR   : name 'spec' is not defined

18-03-15 15:34 INFO    : ************ token ***************
18-03-15 15:34 INFO    : Checking the syntax
18-03-15 15:34 INFO    : Parsing the specification
18-03-15 15:34 INFO    : Checking the well-formedness of the specification
18-03-15 15:34 INFO    : Checking convergence
18-03-15 15:34 INFO    : Checking safety
18-03-15 15:34 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::
from -> 2
to -> 4

18-03-15 15:34 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires (t != t1);
The value of parameters and variables are ::
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_to0 -> 3
_t11 -> 238

18-03-15 15:34 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from1 -> 2
_V10 -> |T@[Int]Int!val!1|
_to1 -> 3
_t10 -> 239

18-03-15 15:34 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 15:34 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires (t != t1);
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|
_t10 -> 719
_t11 -> 719

18-03-15 15:34 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 15:36 INFO    : ************ token ***************
18-03-15 15:36 INFO    : Checking the syntax
18-03-15 15:36 ERROR   : token::::::
A postcondition might not hold on this return path.
if (t1 > t)
This is the postcondition that might not hold.
ensures V == (if (old(t) > t1) then old(V) else V1);


18-03-15 15:38 INFO    : ************ token ***************
18-03-15 15:38 INFO    : Checking the syntax
18-03-15 15:38 ERROR   : token::::::
A postcondition might not hold on this return path.
if (t1 > t)
This is the postcondition that might not hold.
ensures V == (if (t1 > old(t)) then old(V) else V1);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures t == (if (t1 > old(t)) then old(t) else t1);


18-03-15 15:38 INFO    : ************ token ***************
18-03-15 15:38 INFO    : Checking the syntax
18-03-15 15:38 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures t == (if (t1 > old(t)) then old(t) else t1);


18-03-15 15:39 INFO    : ************ token ***************
18-03-15 15:39 INFO    : Checking the syntax
18-03-15 15:39 INFO    : Parsing the specification
18-03-15 15:39 INFO    : Checking the well-formedness of the specification
18-03-15 15:39 INFO    : Checking convergence
18-03-15 15:39 INFO    : Checking safety
18-03-15 15:39 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::
from -> 2
to -> 4

18-03-15 15:39 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires (t != t1);
The value of parameters and variables are ::
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_to0 -> 3
_t11 -> 238

18-03-15 15:39 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to1 -> 3
_from1 -> 2
_V10 -> |T@[Int]Int!val!1|
_t10 -> 719

18-03-15 15:39 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 15:39 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires (t != t1);
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|
_t10 -> 719
_t11 -> 719

18-03-15 15:39 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 15:39 INFO    : ************ token ***************
18-03-15 15:39 INFO    : Checking the syntax
18-03-15 15:39 INFO    : Parsing the specification
18-03-15 15:39 INFO    : Checking the well-formedness of the specification
18-03-15 15:39 INFO    : Checking convergence
18-03-15 15:39 INFO    : Checking safety
18-03-15 15:39 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::
from -> 2
to -> 4

18-03-15 15:39 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 719
_to1 -> 3
_from1 -> 2
_V10 -> |T@[Int]Int!val!1|

18-03-15 15:39 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 15:39 INFO    : The tokens are as follows ::
transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 15:41 INFO    : ************ token ***************
18-03-15 15:41 INFO    : Checking the syntax
18-03-15 15:41 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (exists r:int :: V[r] == 1);


18-03-15 15:56 INFO    : ************ token ***************
18-03-15 15:56 INFO    : Checking the syntax
18-03-15 15:56 INFO    : Parsing the specification
18-03-15 15:56 INFO    : Checking the well-formedness of the specification
18-03-15 15:56 INFO    : Checking convergence
18-03-15 15:56 INFO    : Checking safety
18-03-15 15:56 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 719
_V10 -> |T@[Int]Int!val!1|
_to1 -> 3
_from1 -> 2

18-03-15 15:56 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4
_from0 -> 2
_from1 -> 2

18-03-15 15:56 INFO    : The tokens are as follows ::
transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 15:58 INFO    : ************ token ***************
18-03-15 15:58 INFO    : Checking the syntax
18-03-15 15:58 ERROR   : token::::::
A postcondition might not hold on this return path.
if (t1 > t)
This is the postcondition that might not hold.
ensures V == (if (t1 >= old(t)) then V1 else old(V));


18-03-15 16:02 INFO    : ************ token ***************
18-03-15 16:02 INFO    : Checking the syntax
18-03-15 16:02 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(3,1): error: EOF expected
1 parse errors detected in results/token.bpl



18-03-15 16:02 INFO    : ************ token ***************
18-03-15 16:02 INFO    : Checking the syntax
18-03-15 16:02 INFO    : Parsing the specification
18-03-15 16:02 INFO    : Checking the well-formedness of the specification
18-03-15 16:02 INFO    : Checking convergence
18-03-15 16:02 INFO    : Checking safety
18-03-15 16:02 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_to1);
This is the precondition that might not hold.
requires (V[this] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4

18-03-15 16:02 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires (t != t1);
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|
_t10 -> 720
_t11 -> 720
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|
_t10 -> 720
_t11 -> 721

18-03-15 16:02 INFO    : The tokens are as follows ::
transfer:
 should be executed while acquiring the token.
Token shared with transfer on []

merge:
merge should be executed while acquiring the token.
Token shared with 

18-03-15 16:05 INFO    : ************ token ***************
18-03-15 16:05 INFO    : Checking the syntax
18-03-15 16:05 INFO    : Parsing the specification
18-03-15 16:05 INFO    : Checking the well-formedness of the specification
18-03-15 16:05 INFO    : Checking convergence
18-03-15 16:05 INFO    : Checking safety
18-03-15 16:05 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_to1);
This is the precondition that might not hold.
requires (V[this] == 1);
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!1|
_to1 -> 3
_t10 -> 719

18-03-15 16:05 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_to1);
This is the precondition that might not hold.
requires (V[this] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4

18-03-15 16:05 INFO    : The tokens are as follows ::
transfer:
merge should be executed while acquiring the token.
Token shared with transfer on []

18-03-15 16:06 INFO    : ************ token ***************
18-03-15 16:06 INFO    : Checking the syntax
18-03-15 16:06 INFO    : Parsing the specification
18-03-15 16:06 INFO    : Checking the well-formedness of the specification
18-03-15 16:06 INFO    : Checking convergence
18-03-15 16:06 INFO    : Checking safety
18-03-15 16:06 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!1|
_from1 -> 2
_to1 -> 3
_t10 -> 719

18-03-15 16:06 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:06 INFO    : The tokens are as follows ::
transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:09 INFO    : ************ token ***************
18-03-15 16:09 INFO    : Checking the syntax
18-03-15 16:09 INFO    : Parsing the specification
18-03-15 16:09 INFO    : Checking the well-formedness of the specification
18-03-15 16:09 INFO    : Checking convergence
18-03-15 16:09 INFO    : Checking safety
18-03-15 16:09 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t != t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_from0 -> 2
_to0 -> 3
_V11 -> |T@[Int]Int!val!1|
_t11 -> 237

18-03-15 16:09 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:09 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t != t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|
_t10 -> 719
_t11 -> 718

18-03-15 16:09 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
 should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:09 INFO    : ************ token ***************
18-03-15 16:09 INFO    : Checking the syntax
18-03-15 16:09 INFO    : Parsing the specification
18-03-15 16:09 INFO    : Checking the well-formedness of the specification
18-03-15 16:09 INFO    : Checking convergence
18-03-15 16:09 INFO    : Checking safety
18-03-15 16:10 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_t11 -> 238
_to0 -> 3
_V11 -> |T@[Int]Int!val!1|
_from0 -> 2

18-03-15 16:10 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 719
_to1 -> 3
_V10 -> |T@[Int]Int!val!1|
_from1 -> 2

18-03-15 16:10 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4
_from0 -> 2
_from1 -> 2

18-03-15 16:10 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_t10 -> 719
_t11 -> 719
_V10 -> |T@[Int]Int!val!2|
_V11 -> |T@[Int]Int!val!1|

18-03-15 16:10 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:11 INFO    : ************ token ***************
18-03-15 16:11 INFO    : Checking the syntax
18-03-15 16:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(39,78): error: ")" expected
1 parse errors detected in results/token.bpl



18-03-15 16:11 INFO    : ************ token ***************
18-03-15 16:11 INFO    : Checking the syntax
18-03-15 16:11 INFO    : Parsing the specification
18-03-15 16:11 INFO    : Checking the well-formedness of the specification
18-03-15 16:11 INFO    : Checking convergence
18-03-15 16:11 INFO    : Checking safety
18-03-15 16:11 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_from0 -> 2
_to0 -> 3
_t11 -> 238
_V11 -> |T@[Int]Int!val!1|

18-03-15 16:11 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from1 -> 2
_to1 -> 3
_t10 -> 719
_V10 -> |T@[Int]Int!val!1|

18-03-15 16:11 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:11 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_t10 -> 719
_t11 -> 719
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|

18-03-15 16:11 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:12 INFO    : ************ token ***************
18-03-15 16:12 INFO    : Checking the syntax
18-03-15 16:12 INFO    : Parsing the specification
18-03-15 16:12 INFO    : Checking the well-formedness of the specification
18-03-15 16:12 INFO    : Checking convergence
18-03-15 16:12 INFO    : Checking safety
18-03-15 16:12 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_t11 -> 238
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_to0 -> 3

18-03-15 16:12 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to1 -> 3
_from1 -> 2
_t10 -> 719
_V10 -> |T@[Int]Int!val!1|

18-03-15 16:12 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:12 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_t10 -> 719
_t11 -> 719
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|

18-03-15 16:12 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:13 INFO    : ************ token ***************
18-03-15 16:13 INFO    : Checking the syntax
18-03-15 16:13 INFO    : Parsing the specification
18-03-15 16:13 INFO    : Checking the well-formedness of the specification
18-03-15 16:13 INFO    : Checking convergence
18-03-15 16:13 INFO    : Checking safety
18-03-15 16:13 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
The value of parameters and variables are ::
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_to0 -> 3
_t11 -> 798

18-03-15 16:13 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from1 -> 2
_V10 -> |T@[Int]Int!val!1|
_to1 -> 5
_t10 -> 719

18-03-15 16:13 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:13 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
The value of parameters and variables are ::
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|
_t10 -> (- 715)
_t11 -> 797

18-03-15 16:13 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:13 INFO    : ************ token ***************
18-03-15 16:13 INFO    : Checking the syntax
18-03-15 16:13 INFO    : Parsing the specification
18-03-15 16:13 INFO    : Checking the well-formedness of the specification
18-03-15 16:13 INFO    : Checking convergence
18-03-15 16:13 INFO    : Checking safety
18-03-15 16:13 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 719
_from1 -> 4
_to1 -> 2
_V10 -> |T@[Int]Int!val!1|

18-03-15 16:13 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-03-15 16:13 INFO    : The tokens are as follows ::
transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-15 16:31 INFO    : ************ token ***************
18-03-15 16:31 INFO    : Checking the syntax
18-03-15 16:31 INFO    : Parsing the specification
18-03-15 16:31 INFO    : Checking the well-formedness of the specification
18-03-15 16:31 INFO    : Checking convergence
18-03-15 16:31 INFO    : Checking safety
18-03-15 16:31 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_to0 -> 5
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_t11 -> 798
_to0 -> 3
_from0 -> 2
_V11 -> |T@[Int]Int!val!1|
_t11 -> 797

18-03-15 16:31 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 719
_from1 -> 2
_V10 -> |T@[Int]Int!val!1|
_to1 -> 5

18-03-15 16:31 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4
_from0 -> 2
_from1 -> 2

18-03-15 16:31 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
The value of parameters and variables are ::
_t10 -> 720
_t11 -> 720
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|
_t10 -> 720
_t11 -> 721
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|

18-03-15 16:31 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-03-16 14:37 INFO    : ************ token ***************
18-03-16 14:37 INFO    : Checking the syntax
18-03-16 14:37 INFO    : Parsing the specification
18-03-16 14:37 INFO    : Checking the well-formedness of the specification
18-03-16 14:37 INFO    : Checking convergence
18-03-16 14:37 ERROR   : monotonicity_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_V(V, old(V))&&t >= old(t);
The value of parameters and variables are ::
to -> 4
from -> 2


18-03-21 13:53 INFO    : ************ token ***************
18-03-21 13:53 INFO    : Checking the syntax
18-03-21 13:53 INFO    : Parsing the specification
18-03-21 13:53 INFO    : Checking the well-formedness of the specification
18-03-21 13:53 ERROR   : The function gteq_V should have exactly two parameters

18-03-21 13:53 INFO    : ************ token ***************
18-03-21 13:53 INFO    : Checking the syntax
18-03-21 13:53 INFO    : Parsing the specification
18-03-21 13:53 INFO    : Checking the well-formedness of the specification
18-03-21 13:53 INFO    : Checking convergence
18-03-21 13:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(59,8): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
1 type checking errors detected in results/monotonicity_transfer.bpl



18-03-21 13:55 INFO    : ************ token ***************
18-03-21 13:55 INFO    : Checking the syntax
18-03-21 13:55 INFO    : Parsing the specification
18-03-21 13:55 INFO    : Checking the well-formedness of the specification
18-03-21 13:55 ERROR   : The function gteq_V should have exactly two parameters

18-03-21 14:11 INFO    : ************ token ***************
18-03-21 14:11 INFO    : Checking the syntax
18-03-21 14:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(14,6): Error: undeclared identifier: t1
results/token.bpl(14,11): Error: undeclared identifier: t2
results/token.bpl(14,19): Error: undeclared identifier: t1
results/token.bpl(14,25): Error: undeclared identifier: t2
results/token.bpl(14,48): Error: undeclared identifier: V1
results/token.bpl(14,57): Error: undeclared identifier: V2
6 name resolution errors detected in results/token.bpl


18-03-21 14:12 INFO    : ************ token ***************
18-03-21 14:12 INFO    : Checking the syntax
18-03-21 14:12 INFO    : Parsing the specification
18-03-21 14:12 INFO    : Checking the well-formedness of the specification
18-03-21 14:12 INFO    : Checking convergence
18-03-21 14:12 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(59,8): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
1 type checking errors detected in results/monotonicity_transfer.bpl



18-03-21 14:22 INFO    : ************ token ***************
18-03-21 14:22 INFO    : Checking the syntax
18-03-21 14:22 INFO    : Parsing the specification
18-03-21 14:22 INFO    : Checking the well-formedness of the specification
18-03-21 14:22 INFO    : Checking convergence
18-03-21 14:22 ERROR   : 'Parameter' object has no attribute 'startswith'

18-03-21 14:23 INFO    : ************ token ***************
18-03-21 14:23 INFO    : Checking the syntax
18-03-21 14:23 INFO    : Parsing the specification
18-03-21 14:23 INFO    : Checking the well-formedness of the specification
18-03-21 14:23 INFO    : Checking convergence
18-03-21 14:23 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(59,26): error: ")" expected
1 parse errors detected in results/monotonicity_transfer.bpl



18-03-21 14:24 INFO    : ************ token ***************
18-03-21 14:24 INFO    : Checking the syntax
18-03-21 14:24 INFO    : Parsing the specification
18-03-21 14:24 INFO    : Checking the well-formedness of the specification
18-03-21 14:24 INFO    : Checking convergence
18-03-21 14:24 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/lub_merge.bpl(56,9): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
results/lub_merge.bpl(57,9): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
results/lub_merge.bpl(58,30): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
results/lub_merge.bpl(58,51): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
results/lub_merge.bpl(58,70): Error: wrong number of arguments to function: gteq_V (2 instead of 4)
5 type checking errors detected in results/lub_merge.bpl



18-03-29 14:45 INFO    : ************ bank ***************
18-03-29 14:45 INFO    : Checking the syntax
18-03-29 14:45 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(26,79): error: ")" expected
1 parse errors detected in results/bank.bpl



18-03-29 14:46 INFO    : ************ bank ***************
18-03-29 14:46 INFO    : Checking the syntax
18-03-29 14:46 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(28,49): error: ")" expected
1 parse errors detected in results/bank.bpl



18-03-29 14:46 INFO    : ************ bank ***************
18-03-29 14:46 INFO    : Checking the syntax
18-03-29 14:46 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(4,27): Error: undeclared identifier: withdraw
results/bank.bpl(4,44): Error: undeclared identifier: deposit
results/bank.bpl(16,50): Error: undeclared identifier: deposit
results/bank.bpl(16,77): Error: undeclared identifier: withdraw
results/bank.bpl(26,69): Error: undeclared identifier: deposit
results/bank.bpl(26,112): Error: undeclared identifier: deposit
results/bank.bpl(27,72): Error: undeclared identifier: deposit
results/bank.bpl(27,115): Error: undeclared identifier: deposit
results/bank.bpl(28,38): Error: undeclared identifier: withdraw
results/bank.bpl(28,82): Error: undeclared identifier: withdraw
results/bank.bpl(30,28): Error: undeclared identifier: deposit
results/bank.bpl(30,66): Error: undeclared identifier: deposit
results/bank.bpl(35,35): Error: undeclared identifier: deposit
results/bank.bpl(35,72): Error: undeclared identifier: withdraw
results/bank.bpl(37,69): Error: undeclared identifier: withdraw
results/bank.bpl(37,113): Error: undeclared identifier: withdraw
results/bank.bpl(38,72): Error: undeclared identifier: withdraw
results/bank.bpl(38,116): Error: undeclared identifier: withdraw
results/bank.bpl(39,38): Error: undeclared identifier: deposit
results/bank.bpl(39,81): Error: undeclared identifier: deposit
results/bank.bpl(41,28): Error: undeclared identifier: withdraw
results/bank.bpl(41,67): Error: undeclared identifier: withdraw
results/bank.bpl(44,40): Error: undeclared type: Replica
results/bank.bpl(44,40): Error: undeclared type: Replica
24 name resolution errors detected in results/bank.bpl


18-03-29 14:47 INFO    : ************ bank ***************
18-03-29 14:47 INFO    : Checking the syntax
18-03-29 14:47 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(4,27): Error: undeclared identifier: withdraw
results/bank.bpl(4,44): Error: undeclared identifier: deposit
results/bank.bpl(16,50): Error: undeclared identifier: deposit
results/bank.bpl(16,77): Error: undeclared identifier: withdraw
results/bank.bpl(25,102): Error: undeclared identifier: deposit
results/bank.bpl(25,145): Error: undeclared identifier: deposit
results/bank.bpl(25,227): Error: undeclared identifier: deposit
results/bank.bpl(25,270): Error: undeclared identifier: deposit
results/bank.bpl(25,310): Error: undeclared identifier: withdraw
results/bank.bpl(25,354): Error: undeclared identifier: withdraw
results/bank.bpl(27,28): Error: undeclared identifier: deposit
results/bank.bpl(27,66): Error: undeclared identifier: deposit
results/bank.bpl(32,35): Error: undeclared identifier: deposit
results/bank.bpl(32,72): Error: undeclared identifier: withdraw
results/bank.bpl(33,102): Error: undeclared identifier: withdraw
results/bank.bpl(33,146): Error: undeclared identifier: withdraw
results/bank.bpl(33,229): Error: undeclared identifier: withdraw
results/bank.bpl(33,273): Error: undeclared identifier: withdraw
results/bank.bpl(33,314): Error: undeclared identifier: deposit
results/bank.bpl(33,357): Error: undeclared identifier: deposit
results/bank.bpl(35,28): Error: undeclared identifier: withdraw
results/bank.bpl(35,67): Error: undeclared identifier: withdraw
results/bank.bpl(38,40): Error: undeclared type: Replica
results/bank.bpl(38,40): Error: undeclared type: Replica
24 name resolution errors detected in results/bank.bpl


18-03-29 14:49 INFO    : ************ bank ***************
18-03-29 14:49 INFO    : Checking the syntax
18-03-29 14:49 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(4,27): Error: undeclared identifier: withdraw
results/bank.bpl(4,44): Error: undeclared identifier: deposit
results/bank.bpl(16,50): Error: undeclared identifier: deposit
results/bank.bpl(16,77): Error: undeclared identifier: withdraw
results/bank.bpl(25,102): Error: undeclared identifier: deposit
results/bank.bpl(25,145): Error: undeclared identifier: deposit
results/bank.bpl(25,227): Error: undeclared identifier: deposit
results/bank.bpl(25,270): Error: undeclared identifier: deposit
results/bank.bpl(25,310): Error: undeclared identifier: withdraw
results/bank.bpl(25,354): Error: undeclared identifier: withdraw
results/bank.bpl(27,28): Error: undeclared identifier: deposit
results/bank.bpl(27,66): Error: undeclared identifier: deposit
results/bank.bpl(32,35): Error: undeclared identifier: deposit
results/bank.bpl(32,72): Error: undeclared identifier: withdraw
results/bank.bpl(33,102): Error: undeclared identifier: withdraw
results/bank.bpl(33,146): Error: undeclared identifier: withdraw
results/bank.bpl(33,229): Error: undeclared identifier: withdraw
results/bank.bpl(33,273): Error: undeclared identifier: withdraw
results/bank.bpl(33,314): Error: undeclared identifier: deposit
results/bank.bpl(33,357): Error: undeclared identifier: deposit
results/bank.bpl(35,28): Error: undeclared identifier: withdraw
results/bank.bpl(35,67): Error: undeclared identifier: withdraw
results/bank.bpl(38,40): Error: undeclared type: Replica
results/bank.bpl(38,40): Error: undeclared type: Replica
24 name resolution errors detected in results/bank.bpl


18-03-29 14:52 INFO    : ************ bank ***************
18-03-29 14:52 INFO    : Checking the syntax
18-03-29 14:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(4,27): Error: undeclared identifier: w
results/bank.bpl(4,37): Error: undeclared identifier: d
results/bank.bpl(16,50): Error: undeclared identifier: d
results/bank.bpl(16,71): Error: undeclared identifier: w
results/bank.bpl(25,102): Error: undeclared identifier: d
results/bank.bpl(25,139): Error: undeclared identifier: d
results/bank.bpl(25,215): Error: undeclared identifier: d
results/bank.bpl(25,252): Error: undeclared identifier: d
results/bank.bpl(25,286): Error: undeclared identifier: w
results/bank.bpl(25,323): Error: undeclared identifier: w
results/bank.bpl(27,28): Error: undeclared identifier: d
results/bank.bpl(27,60): Error: undeclared identifier: d
results/bank.bpl(32,35): Error: undeclared identifier: d
results/bank.bpl(32,66): Error: undeclared identifier: w
results/bank.bpl(33,102): Error: undeclared identifier: w
results/bank.bpl(33,139): Error: undeclared identifier: w
results/bank.bpl(33,215): Error: undeclared identifier: w
results/bank.bpl(33,252): Error: undeclared identifier: w
results/bank.bpl(33,286): Error: undeclared identifier: d
results/bank.bpl(33,323): Error: undeclared identifier: d
results/bank.bpl(35,28): Error: undeclared identifier: w
results/bank.bpl(35,60): Error: undeclared identifier: w
results/bank.bpl(38,40): Error: undeclared type: Replica
results/bank.bpl(38,40): Error: undeclared type: Replica
24 name resolution errors detected in results/bank.bpl


18-03-29 14:52 INFO    : ************ bank ***************
18-03-29 14:52 INFO    : Checking the syntax
18-03-29 14:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(40,40): Error: undeclared type: Replica
results/bank.bpl(40,40): Error: undeclared type: Replica
2 name resolution errors detected in results/bank.bpl


18-03-29 14:52 INFO    : ************ bank ***************
18-03-29 14:52 INFO    : Checking the syntax
18-03-29 14:52 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[client][replica][d] == old(balances)[client][replica][d] + value) && ((c != client || r != replica) ==> balances[client][replica][d] == old(balances)[client][replica][d]) && (balances[client][replica][w] == old(balances)[client][replica][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[client][replica][w] == old(balances)[client][replica][w] + value) && ((c != client || r != replica) ==> balances[client][replica][w] == old(balances)[client][replica][w]) && (balances[client][replica][d] == old(balances)[client][replica][d]));


18-03-29 15:58 INFO    : ************ bank ***************
18-03-29 15:58 INFO    : Checking the syntax
18-03-29 15:58 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[c][r][d] == old(balances)[c][r][d] + value) && ((c != client || r != replica) ==> balances[c][r][d] == old(balances)[c][r][d]) && (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[c][r][w] == old(balances)[c][r][w] + value) && ((c != client || r != replica) ==> balances[c][r][w] == old(balances)[c][r][w]) && (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 15:59 INFO    : ************ bank ***************
18-03-29 15:59 INFO    : Checking the syntax
18-03-29 15:59 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[c][r][w] == old(balances)[c][r][w] + value) && ((c != client || r != replica) ==> balances[c][r][w] == old(balances)[c][r][w]) && (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 16:01 INFO    : ************ bank ***************
18-03-29 16:01 INFO    : Checking the syntax
18-03-29 16:01 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: ((c == client && r == replica) ==> balances[c][r][w] == old(balances)[c][r][w] + value) && ((c != client || r != replica) ==> balances[c][r][w] == old(balances)[c][r][w]) && (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 16:02 INFO    : ************ bank ***************
18-03-29 16:02 INFO    : Checking the syntax
18-03-29 16:02 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 16:02 INFO    : ************ bank ***************
18-03-29 16:02 INFO    : Checking the syntax
18-03-29 16:02 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 16:02 INFO    : ************ bank ***************
18-03-29 16:02 INFO    : Checking the syntax
18-03-29 16:02 ERROR   : bank::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][w] == old(balances)[c][r][w]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (balances[c][r][d] == old(balances)[c][r][d]));


18-03-29 16:05 INFO    : ************ bank ***************
18-03-29 16:05 INFO    : Checking the syntax
18-03-29 16:05 INFO    : Parsing the specification
18-03-29 16:05 INFO    : Checking the well-formedness of the specification
18-03-29 16:05 INFO    : Checking convergence
18-03-29 16:05 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_deposit.bpl(62,21): Error: undeclared identifier: one
results/monotonicity_deposit.bpl(62,25): Error: undeclared identifier: two
2 name resolution errors detected in results/monotonicity_deposit.bpl


18-03-29 16:06 INFO    : ************ bank ***************
18-03-29 16:06 INFO    : Checking the syntax
18-03-29 16:06 INFO    : Parsing the specification
18-03-29 16:06 INFO    : Checking the well-formedness of the specification
18-03-29 16:06 INFO    : Checking convergence
18-03-29 16:06 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_deposit.bpl(62,21): Error: undeclared identifier: balances1
results/monotonicity_deposit.bpl(62,31): Error: undeclared identifier: balances2
2 name resolution errors detected in results/monotonicity_deposit.bpl


18-03-29 16:07 INFO    : ************ bank ***************
18-03-29 16:07 INFO    : Checking the syntax
18-03-29 16:07 INFO    : Parsing the specification
18-03-29 16:07 INFO    : Checking the well-formedness of the specification
18-03-29 16:07 INFO    : Checking convergence
18-03-29 16:07 INFO    : Checking safety
18-03-29 16:07 ERROR   : stability_merge_proc_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_replica1 -> T@ReplicaID!val!0
_client1 -> T@Client!val!0
_balances10 -> |T@[Client][ReplicaID][Txn]Int!val!1|
_value1 -> 2

18-03-29 16:07 ERROR   : stability_withdraw_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_replica0 -> T@ReplicaID!val!0
_replica1 -> T@ReplicaID!val!0
_client0 -> T@Client!val!0
_client1 -> T@Client!val!0
_value0 -> 1
_value1 -> 1

18-03-29 16:07 INFO    : The tokens are as follows ::
withdraw:
merge_proc should be executed while acquiring the token.
Token shared with withdraw on ['_replica0 != _replica1', '_client0 != _client1', '_replica0 != _replica1 && _client0 != _client1', '_replica0 != _replica1 && _value0 != _value1', '_client0 != _client1 && _value0 != _value1', '_replica0 != _replica1 && _client0 != _client1 && _value0 != _value1']

18-03-29 16:08 INFO    : ************ bank ***************
18-03-29 16:08 INFO    : Checking the syntax
18-03-29 16:08 INFO    : Parsing the specification
18-03-29 16:08 INFO    : Checking the well-formedness of the specification
18-03-29 16:08 INFO    : Checking convergence
18-03-29 16:08 INFO    : Checking safety
18-03-29 16:08 ERROR   : stability_merge_proc_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_value1 -> 2
_client1 -> T@Client!val!0
_replica1 -> T@ReplicaID!val!0
_balances10 -> |T@[Client][ReplicaID][Txn]Int!val!1|

18-03-29 16:08 ERROR   : stability_withdraw_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_value0 -> 1
_value1 -> 1
_client0 -> T@Client!val!0
_client1 -> T@Client!val!0
_replica0 -> T@ReplicaID!val!0
_replica1 -> T@ReplicaID!val!0

18-03-29 16:08 INFO    : The tokens are as follows ::
withdraw:
merge_proc should be executed while acquiring the token.
Token shared with withdraw on ['_client0 != _client1', '_replica0 != _replica1', '_value0 != _value1 && _client0 != _client1', '_value0 != _value1 && _replica0 != _replica1', '_client0 != _client1 && _replica0 != _replica1', '_value0 != _value1 && _client0 != _client1 && _replica0 != _replica1']

18-04-26 12:02 INFO    : ************ bank ***************
18-04-26 12:02 INFO    : Checking the syntax
18-04-26 12:02 INFO    : Parsing the specification
18-04-26 12:02 INFO    : Checking convergence
18-04-26 12:02 INFO    : Checking safety
18-04-26 12:02 ERROR   : stability_merge_proc_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_balances10 -> |T@[Client][ReplicaID][Txn]Int!val!1|
_replica1 -> T@ReplicaID!val!0
_value1 -> 2
_client1 -> T@Client!val!0

18-04-26 12:02 ERROR   : stability_withdraw_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_replica1,_value1);
This is the precondition that might not hold.
requires (balances[client][replica][d] - balances[client][replica][w] >= value + min);
The value of parameters and variables are ::
_replica0 -> T@ReplicaID!val!0
_replica1 -> T@ReplicaID!val!0
_value0 -> 1
_value1 -> 1
_client0 -> T@Client!val!0
_client1 -> T@Client!val!0

18-04-26 12:02 INFO    : The tokens are as follows ::
withdraw:
merge_proc should be executed while acquiring the token.
Token shared with withdraw on ['_replica0 != _replica1', '_client0 != _client1', '_replica0 != _replica1 && _value0 != _value1', '_replica0 != _replica1 && _client0 != _client1', '_value0 != _value1 && _client0 != _client1', '_replica0 != _replica1 && _value0 != _value1 && _client0 != _client1']

18-04-26 12:02 INFO    : ************ token ***************
18-04-26 12:02 INFO    : Checking the syntax
18-04-26 12:02 INFO    : Parsing the specification
18-04-26 12:02 INFO    : Checking convergence
18-04-26 12:02 INFO    : Checking safety
18-04-26 12:02 ERROR   : stability_transfer_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
The value of parameters and variables are ::
_to0 -> 4
_V11 -> |T@[Int]Int!val!1|
_from0 -> 2
_t11 -> 798
_to0 -> 3
_V11 -> |T@[Int]Int!val!1|
_from0 -> 2
_t11 -> 797

18-04-26 12:02 ERROR   : stability_merge_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_t10 -> 238
_V10 -> |T@[Int]Int!val!1|
_from1 -> 2
_to1 -> 5

18-04-26 12:02 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_to0 -> 3
_to1 -> 4
_from0 -> 2
_from1 -> 2

18-04-26 12:02 ERROR   : stability_merge_merge::::::
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((t == t1 ==> (forall r:int :: V[r] == V1[r])));
A precondition for this call might not hold.
call merge(_V11,_t11);
This is the precondition that might not hold.
requires ((V[this] == 1 ==> t >= t1));
The value of parameters and variables are ::
_t10 -> 720
_t11 -> 720
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|
_t10 -> 720
_t11 -> 721
_V10 -> |T@[Int]Int!val!1|
_V11 -> |T@[Int]Int!val!2|

18-04-26 12:02 INFO    : The tokens are as follows ::
merge:
merge should be executed while acquiring the token.
Token shared with transfer on []

transfer:
merge should be executed while acquiring the token.
Token shared with transfer on ['_from0 != _from1']

18-04-26 12:04 INFO    : ************ token ***************
18-04-26 12:04 INFO    : Checking the syntax
18-04-26 12:04 INFO    : Parsing the specification
18-04-26 12:04 INFO    : Checking convergence
18-04-26 12:04 INFO    : Checking safety
18-04-26 12:04 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-04-26 21:42 INFO    : ************ token ***************
18-04-26 21:42 INFO    : Checking the syntax
18-04-26 21:42 INFO    : Parsing the specification
18-04-26 21:42 INFO    : Checking convergence
18-04-26 21:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(67,11): error: ";" expected
1 parse errors detected in results/monotonicity_transfer.bpl



18-04-26 21:43 INFO    : ************ token ***************
18-04-26 21:43 INFO    : Checking the syntax
18-04-26 21:43 INFO    : Parsing the specification
18-04-26 21:43 INFO    : Checking convergence
18-04-26 21:44 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(67,12): error: ";" expected
1 parse errors detected in results/monotonicity_transfer.bpl



18-04-26 21:45 INFO    : ************ token ***************
18-04-26 21:45 INFO    : Checking the syntax
18-04-26 21:45 INFO    : Parsing the specification
18-04-26 21:45 INFO    : Checking the well-formedness of the specification
18-04-26 21:45 ERROR   : All global variables which are not the basic datatype needs a greater than or equal to function defined

18-04-26 21:46 INFO    : ************ token ***************
18-04-26 21:46 INFO    : Checking the syntax
18-04-26 21:46 INFO    : Parsing the specification
18-04-26 21:46 INFO    : Checking the well-formedness of the specification
18-04-26 21:46 INFO    : Checking convergence
18-04-26 21:46 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_transfer.bpl(67,12): error: ";" expected
1 parse errors detected in results/monotonicity_transfer.bpl



18-04-26 21:48 INFO    : ************ token ***************
18-04-26 21:48 INFO    : Checking the syntax
18-04-26 21:48 INFO    : Parsing the specification
18-04-26 21:48 INFO    : Checking the well-formedness of the specification
18-04-26 21:48 INFO    : Checking convergence
18-04-26 21:48 ERROR   : monotonicity_transfer::::::
A precondition for this call might not hold.
call transfer(_from, _to);
This is the precondition that might not hold.
requires (from != to);
A precondition for this call might not hold.
call transfer(_from, _to);
This is the precondition that might not hold.
requires (V[from] == 1);
A precondition for this call might not hold.
call transfer(_from, _to);
This is the precondition that might not hold.
requires (inv(V, t));
The value of parameters and variables are ::


18-04-26 22:11 INFO    : ************ token ***************
18-04-26 22:11 INFO    : Checking the syntax
18-04-26 22:11 INFO    : Parsing the specification
18-04-26 22:11 INFO    : Checking the well-formedness of the specification
18-04-26 22:11 INFO    : Checking convergence
18-04-26 22:11 ERROR   : name 'SpecificationGenerator' is not defined

18-04-26 22:11 INFO    : ************ token ***************
18-04-26 22:11 INFO    : Checking the syntax
18-04-26 22:12 INFO    : Parsing the specification
18-04-26 22:12 INFO    : Checking the well-formedness of the specification
18-04-26 22:12 INFO    : Checking convergence
18-04-26 22:12 ERROR   : name 'Parameter' is not defined

18-04-26 22:25 INFO    : ************ token ***************
18-04-26 22:25 INFO    : Checking the syntax
18-04-26 22:25 INFO    : Parsing the specification
18-04-26 22:25 INFO    : Checking the well-formedness of the specification
18-04-26 22:25 INFO    : Checking convergence
18-04-26 22:25 INFO    : Checking safety
18-04-26 22:25 ERROR   : 'Specification' object has no attribute 'merges'

18-04-26 22:25 INFO    : ************ token ***************
18-04-26 22:25 INFO    : Checking the syntax
18-04-26 22:25 INFO    : Parsing the specification
18-04-26 22:25 INFO    : Checking the well-formedness of the specification
18-04-26 22:25 INFO    : Checking convergence
18-04-26 22:25 INFO    : Checking safety
18-04-26 22:25 ERROR   : can only concatenate list (not "Procedure") to list

18-04-26 22:28 INFO    : ************ token ***************
18-04-26 22:28 INFO    : Checking the syntax
18-04-26 22:28 INFO    : Parsing the specification
18-04-26 22:28 INFO    : Checking the well-formedness of the specification
18-04-26 22:28 INFO    : Checking convergence
18-04-26 22:28 INFO    : Checking safety
18-04-26 22:28 ERROR   : 

18-04-26 22:29 INFO    : ************ token ***************
18-04-26 22:29 INFO    : Checking the syntax
18-04-26 22:29 INFO    : Parsing the specification
18-04-26 22:29 INFO    : Checking the well-formedness of the specification
18-04-26 22:29 INFO    : Checking convergence
18-04-26 22:29 INFO    : Checking safety
18-04-26 22:29 ERROR   : 

18-04-26 22:29 INFO    : ************ token ***************
18-04-26 22:29 INFO    : Checking the syntax
18-04-26 22:29 INFO    : Parsing the specification
18-04-26 22:29 INFO    : Checking the well-formedness of the specification
18-04-26 22:29 INFO    : Checking convergence
18-04-26 22:29 INFO    : Checking safety
18-04-26 22:29 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_from1,_to1);
This is the precondition that might not hold.
requires (V[from] == 1);
The value of parameters and variables are ::
_from0 -> 2
_from1 -> 2
_to0 -> 3
_to1 -> 4

18-04-26 22:29 ERROR   : 

18-04-26 22:30 INFO    : ************ token ***************
18-04-26 22:30 INFO    : Checking the syntax
18-04-26 22:30 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(22,12): Error: invalid argument types (ReplicaId and int) to binary operator !=
results/token.bpl(23,11): Error: invalid type for argument 0 in map select: ReplicaId (expected: int)
results/token.bpl(31,6): Error: invalid type for argument 0 in map assignment: ReplicaId (expected: int)
3 type checking errors detected in results/token.bpl



18-04-26 22:32 INFO    : ************ token ***************
18-04-26 22:32 INFO    : Checking the syntax
18-04-26 22:32 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(28,18): Error: undeclared type: iReplicaIdnt
1 name resolution errors detected in results/token.bpl


18-04-26 22:32 INFO    : ************ token ***************
18-04-26 22:32 INFO    : Checking the syntax
18-04-26 22:32 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(40,41): Error: invalid type for argument 0 in map select: int (expected: ReplicaId)
results/token.bpl(40,50): Error: invalid type for argument 0 in map select: int (expected: ReplicaId)
2 type checking errors detected in results/token.bpl



18-04-26 22:33 INFO    : ************ token ***************
18-04-26 22:33 INFO    : Checking the syntax
18-04-26 22:33 INFO    : Parsing the specification
18-04-26 22:33 INFO    : Checking the well-formedness of the specification
18-04-26 22:33 INFO    : Checking convergence
18-04-26 22:33 INFO    : Checking safety
18-04-26 22:33 ERROR   : stability_transfer_transfer::::::
A precondition for this call might not hold.
call transfer(_to1);
This is the precondition that might not hold.
requires (V[me] == 1);
The value of parameters and variables are ::
_to0 -> T@ReplicaId!val!1
_to1 -> T@ReplicaId!val!2

18-04-26 22:33 ERROR   : 

18-04-27 10:49 INFO    : ************ bank ***************
18-04-27 10:49 INFO    : Checking the syntax
18-04-27 10:49 INFO    : Parsing the specification
18-04-27 10:49 INFO    : Checking the well-formedness of the specification
18-04-27 10:49 INFO    : Checking convergence
18-04-27 10:49 ERROR   : monotonicity_deposit::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_counter(balances,old(balances));
The value of parameters and variables are ::


18-04-27 10:53 INFO    : ************ bank ***************
18-04-27 10:53 INFO    : Checking the syntax
18-04-27 10:53 INFO    : Parsing the specification
18-04-27 10:53 INFO    : Checking the well-formedness of the specification
18-04-27 10:53 INFO    : Checking convergence
18-04-27 10:54 INFO    : Checking safety
18-04-27 10:54 ERROR   : stability_withdraw_withdraw::::::
A precondition for this call might not hold.
call withdraw(_client1,_value1);
This is the precondition that might not hold.
requires (balances[client][me][d] - balances[client][me][w] >= value + min);
The value of parameters and variables are ::
_client0 -> T@Client!val!0
_client1 -> T@Client!val!0
_value0 -> 1
_value1 -> 1

18-04-27 10:54 ERROR   : 

18-05-02 15:59 INFO    : ************ bank ***************
18-05-02 15:59 INFO    : Checking the syntax
18-05-02 15:59 INFO    : Parsing the specification
18-05-02 15:59 INFO    : Checking the well-formedness of the specification
18-05-02 15:59 INFO    : Checking convergence
18-05-02 15:59 INFO    : Checking safety
18-05-02 15:59 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge_proc.bpl(64,12): Error: undeclared identifier: balances1
results/safety_merge_proc.bpl(67,11): Error: undeclared identifier: balances1
2 name resolution errors detected in results/safety_merge_proc.bpl

18-05-02 15:59 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_deposit.bpl(67,12): Error: undeclared identifier: balances1
results/safety_deposit.bpl(70,11): Error: undeclared identifier: balances1
2 name resolution errors detected in results/safety_deposit.bpl

18-05-02 15:59 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_withdraw.bpl(68,12): Error: undeclared identifier: balances1
results/safety_withdraw.bpl(71,11): Error: undeclared identifier: balances1
2 name resolution errors detected in results/safety_withdraw.bpl

18-05-02 15:59 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge_proc.bpl(64,12): Error: undeclared identifier: balances1
results/safety_merge_proc.bpl(67,11): Error: undeclared identifier: balances1
2 name resolution errors detected in results/safety_merge_proc.bpl

18-05-02 15:59 ERROR   : 

18-05-02 16:01 INFO    : ************ bank ***************
18-05-02 16:01 INFO    : Checking the syntax
18-05-02 16:01 INFO    : Parsing the specification
18-05-02 16:01 INFO    : Checking the well-formedness of the specification
18-05-02 16:01 INFO    : Checking convergence
18-05-02 16:01 INFO    : Checking safety
18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge_proc.bpl(62,9): error: invalid UnaryExpression
results/safety_merge_proc.bpl(65,8): error: invalid UnaryExpression
2 parse errors detected in results/safety_merge_proc.bpl


18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_deposit.bpl(66,9): error: invalid UnaryExpression
results/safety_deposit.bpl(69,8): error: invalid UnaryExpression
2 parse errors detected in results/safety_deposit.bpl


18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_withdraw.bpl(67,9): error: invalid UnaryExpression
results/safety_withdraw.bpl(70,8): error: invalid UnaryExpression
2 parse errors detected in results/safety_withdraw.bpl


18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge_proc.bpl(62,9): error: invalid UnaryExpression
results/safety_merge_proc.bpl(65,8): error: invalid UnaryExpression
2 parse errors detected in results/safety_merge_proc.bpl


18-05-02 16:01 ERROR   : 

18-05-02 16:01 INFO    : ************ token ***************
18-05-02 16:01 INFO    : Checking the syntax
18-05-02 16:01 INFO    : Parsing the specification
18-05-02 16:01 INFO    : Checking the well-formedness of the specification
18-05-02 16:01 INFO    : Checking convergence
18-05-02 16:01 INFO    : Checking safety
18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge.bpl(71,12): Error: undeclared identifier: V1
results/safety_merge.bpl(71,16): Error: undeclared identifier: t1
results/safety_merge.bpl(71,37): Error: undeclared identifier: t1
results/safety_merge.bpl(71,75): Error: undeclared identifier: V1
results/safety_merge.bpl(71,107): Error: undeclared identifier: t1
results/safety_merge.bpl(74,11): Error: undeclared identifier: V1
results/safety_merge.bpl(74,15): Error: undeclared identifier: t1
results/safety_merge.bpl(74,36): Error: undeclared identifier: t1
results/safety_merge.bpl(74,74): Error: undeclared identifier: V1
results/safety_merge.bpl(74,106): Error: undeclared identifier: t1
10 name resolution errors detected in results/safety_merge.bpl

18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_transfer.bpl(71,12): Error: undeclared identifier: V1
results/safety_transfer.bpl(71,16): Error: undeclared identifier: t1
results/safety_transfer.bpl(71,37): Error: undeclared identifier: t1
results/safety_transfer.bpl(71,75): Error: undeclared identifier: V1
results/safety_transfer.bpl(71,107): Error: undeclared identifier: t1
results/safety_transfer.bpl(74,11): Error: undeclared identifier: V1
results/safety_transfer.bpl(74,15): Error: undeclared identifier: t1
results/safety_transfer.bpl(74,36): Error: undeclared identifier: t1
results/safety_transfer.bpl(74,74): Error: undeclared identifier: V1
results/safety_transfer.bpl(74,106): Error: undeclared identifier: t1
10 name resolution errors detected in results/safety_transfer.bpl

18-05-02 16:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge.bpl(71,12): Error: undeclared identifier: V1
results/safety_merge.bpl(71,16): Error: undeclared identifier: t1
results/safety_merge.bpl(71,37): Error: undeclared identifier: t1
results/safety_merge.bpl(71,75): Error: undeclared identifier: V1
results/safety_merge.bpl(71,107): Error: undeclared identifier: t1
results/safety_merge.bpl(74,11): Error: undeclared identifier: V1
results/safety_merge.bpl(74,15): Error: undeclared identifier: t1
results/safety_merge.bpl(74,36): Error: undeclared identifier: t1
results/safety_merge.bpl(74,74): Error: undeclared identifier: V1
results/safety_merge.bpl(74,106): Error: undeclared identifier: t1
10 name resolution errors detected in results/safety_merge.bpl

18-05-02 16:01 ERROR   : 

18-05-02 16:07 INFO    : ************ token ***************
18-05-02 16:07 INFO    : Checking the syntax
18-05-02 16:07 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r == to ==> V[r] == 1) && (r != to ==> V[r] == 0));


18-05-02 16:09 INFO    : ************ token ***************
18-05-02 16:09 INFO    : Checking the syntax
18-05-02 16:09 ERROR   : token::::::
Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/token.bpl(33,1): Error BP5003: A postcondition might not hold on this return path.
results/token.bpl(25,1): Related location: This is the postcondition that might not hold.
Execution trace:
    results/token.bpl(30,11): anon0

Boogie program verifier finished with 1 verified, 1 error

A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r == to ==> V[r] == 1) && (r != to ==> V[r] == 0));


18-05-02 16:11 INFO    : ************ token ***************
18-05-02 16:11 INFO    : Checking the syntax
18-05-02 16:11 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-05-02 16:12 INFO    : ************ token ***************
18-05-02 16:12 INFO    : Checking the syntax
18-05-02 16:12 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-05-02 16:18 INFO    : ************ token ***************
18-05-02 16:18 INFO    : Checking the syntax
18-05-02 16:18 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-05-02 16:18 INFO    : ************ token ***************
18-05-02 16:18 INFO    : Checking the syntax
18-05-02 16:18 INFO    : Parsing the specification
18-05-02 16:18 INFO    : Checking the well-formedness of the specification
18-05-02 16:18 INFO    : Checking convergence
18-05-02 16:18 INFO    : Checking safety
18-05-02 16:18 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge.bpl(69,14): Error: undeclared identifier: t1
results/safety_merge.bpl(69,52): Error: undeclared identifier: V1
results/safety_merge.bpl(69,84): Error: undeclared identifier: t1
results/safety_merge.bpl(72,13): Error: undeclared identifier: t1
results/safety_merge.bpl(72,51): Error: undeclared identifier: V1
results/safety_merge.bpl(72,83): Error: undeclared identifier: t1
6 name resolution errors detected in results/safety_merge.bpl

18-05-02 16:18 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_transfer.bpl(70,14): Error: undeclared identifier: t1
results/safety_transfer.bpl(70,52): Error: undeclared identifier: V1
results/safety_transfer.bpl(70,84): Error: undeclared identifier: t1
results/safety_transfer.bpl(73,13): Error: undeclared identifier: t1
results/safety_transfer.bpl(73,51): Error: undeclared identifier: V1
results/safety_transfer.bpl(73,83): Error: undeclared identifier: t1
6 name resolution errors detected in results/safety_transfer.bpl

18-05-02 16:18 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge.bpl(69,14): Error: undeclared identifier: t1
results/safety_merge.bpl(69,52): Error: undeclared identifier: V1
results/safety_merge.bpl(69,84): Error: undeclared identifier: t1
results/safety_merge.bpl(72,13): Error: undeclared identifier: t1
results/safety_merge.bpl(72,51): Error: undeclared identifier: V1
results/safety_merge.bpl(72,83): Error: undeclared identifier: t1
6 name resolution errors detected in results/safety_merge.bpl

18-05-02 16:18 ERROR   : 

18-05-02 16:26 INFO    : ************ token ***************
18-05-02 16:26 INFO    : Checking the syntax
18-05-02 16:26 INFO    : Parsing the specification
18-05-02 16:26 INFO    : Checking the well-formedness of the specification
18-05-02 16:26 INFO    : Checking convergence
18-05-02 16:26 INFO    : Checking safety
18-05-02 16:26 ERROR   : name 'p' is not defined
18-05-02 16:26 ERROR   : name 'p' is not defined
18-05-02 16:26 ERROR   : name 'p' is not defined
18-05-02 16:26 ERROR   : 

18-05-02 16:27 INFO    : ************ token ***************
18-05-02 16:27 INFO    : Checking the syntax
18-05-02 16:27 INFO    : Parsing the specification
18-05-02 16:27 INFO    : Checking the well-formedness of the specification
18-05-02 16:27 INFO    : Checking convergence
18-05-02 16:27 INFO    : Checking safety
18-05-02 16:27 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:27 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (old(t) == t ==> (forall r:ReplicaId :: old(V)[r] == V[r])) && (old(V)[me] == 1 ==> old(t) >= t);
The value of parameters and variables are ::

18-05-02 16:27 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:27 ERROR   : 

18-05-02 16:29 INFO    : ************ token ***************
18-05-02 16:29 INFO    : Checking the syntax
18-05-02 16:29 INFO    : Parsing the specification
18-05-02 16:29 INFO    : Checking the well-formedness of the specification
18-05-02 16:29 INFO    : Checking convergence
18-05-02 16:29 INFO    : Checking safety
18-05-02 16:29 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:29 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:29 ERROR   : 'SafetyChecker' object has no attribute 'generate_stability_check'
18-05-02 16:29 ERROR   : 

18-05-02 16:30 INFO    : ************ token ***************
18-05-02 16:30 INFO    : Checking the syntax
18-05-02 16:30 INFO    : Parsing the specification
18-05-02 16:30 INFO    : Checking the well-formedness of the specification
18-05-02 16:30 INFO    : Checking convergence
18-05-02 16:30 INFO    : Checking safety
18-05-02 16:30 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:30 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:30 ERROR   : stability_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (old(t) == t ==> (forall r:ReplicaId :: old(V)[r] == V[r])) && (old(V)[me] == 1 ==> old(t) >= t);
The value of parameters and variables are ::

18-05-02 16:30 ERROR   : 

18-05-02 16:32 INFO    : ************ token ***************
18-05-02 16:32 INFO    : Checking the syntax
18-05-02 16:32 INFO    : Parsing the specification
18-05-02 16:32 INFO    : Checking the well-formedness of the specification
18-05-02 16:32 INFO    : Checking convergence
18-05-02 16:32 INFO    : Checking safety
18-05-02 16:32 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:32 ERROR   : stability_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (old(t) == t ==> (forall r:ReplicaId :: old(V)[r] == V[r])) && (old(V)[me] == 1 ==> old(t) >= t);
The value of parameters and variables are ::

18-05-02 16:32 ERROR   : 

18-05-02 16:39 INFO    : ************ token ***************
18-05-02 16:39 INFO    : Checking the syntax
18-05-02 16:39 INFO    : Parsing the specification
18-05-02 16:39 INFO    : Checking the well-formedness of the specification
18-05-02 16:39 INFO    : Checking convergence
18-05-02 16:40 INFO    : Checking safety
18-05-02 16:40 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:40 ERROR   : 

18-05-02 16:42 INFO    : ************ bank ***************
18-05-02 16:42 INFO    : Checking the syntax
18-05-02 16:42 INFO    : Parsing the specification
18-05-02 16:42 INFO    : Checking the well-formedness of the specification
18-05-02 16:42 INFO    : Checking convergence
18-05-02 16:42 INFO    : Checking safety
18-05-02 16:42 ERROR   : safety_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(balances);
The value of parameters and variables are ::

18-05-02 16:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_deposit.bpl(66,9): error: invalid UnaryExpression
results/stability_deposit.bpl(69,8): error: invalid UnaryExpression
2 parse errors detected in results/stability_deposit.bpl


18-05-02 16:42 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/stability_withdraw.bpl(67,9): error: invalid UnaryExpression
results/stability_withdraw.bpl(70,8): error: invalid UnaryExpression
2 parse errors detected in results/stability_withdraw.bpl


18-05-02 16:42 ERROR   : 

18-05-02 16:44 INFO    : ************ bank ***************
18-05-02 16:44 INFO    : Checking the syntax
18-05-02 16:44 INFO    : Parsing the specification
18-05-02 16:44 INFO    : Checking the well-formedness of the specification
18-05-02 16:44 INFO    : Checking convergence
18-05-02 16:44 INFO    : Checking safety
18-05-02 16:44 ERROR   : safety_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(balances);
The value of parameters and variables are ::

18-05-02 16:44 ERROR   : 

18-05-02 16:44 INFO    : ************ token ***************
18-05-02 16:44 INFO    : Checking the syntax
18-05-02 16:44 INFO    : Parsing the specification
18-05-02 16:44 INFO    : Checking the well-formedness of the specification
18-05-02 16:44 INFO    : Checking convergence
18-05-02 16:44 INFO    : Checking safety
18-05-02 16:44 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-02 16:44 ERROR   : 

18-05-02 16:50 INFO    : ************ token ***************
18-05-02 16:50 INFO    : Checking the syntax
18-05-02 16:50 INFO    : Parsing the specification
18-05-02 16:50 INFO    : Checking the well-formedness of the specification
18-05-02 16:50 INFO    : Checking convergence
18-05-02 16:50 INFO    : Checking safety
18-05-02 16:50 ERROR   : must be str, not NoneType
18-05-02 16:50 ERROR   : 

18-05-02 16:51 INFO    : ************ token ***************
18-05-02 16:51 INFO    : Checking the syntax
18-05-02 16:51 INFO    : Parsing the specification
18-05-02 16:51 INFO    : Checking the well-formedness of the specification
18-05-02 16:51 INFO    : Checking convergence
18-05-02 16:51 INFO    : Checking safety
18-05-02 16:51 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/safety_merge.bpl(71,11): Error: undeclared identifier: V1
results/safety_merge.bpl(71,14): Error: undeclared identifier: t1
2 name resolution errors detected in results/safety_merge.bpl

18-05-02 16:51 ERROR   : 

18-05-02 16:51 INFO    : ************ token ***************
18-05-02 16:51 INFO    : Checking the syntax
18-05-02 16:51 INFO    : Parsing the specification
18-05-02 16:51 INFO    : Checking the well-formedness of the specification
18-05-02 16:51 INFO    : Checking convergence
18-05-02 16:51 INFO    : Checking safety
18-05-02 16:51 INFO    : The specification is safe!!!
18-05-02 16:51 INFO    : ************ bank ***************
18-05-02 16:51 INFO    : Checking the syntax
18-05-02 16:51 INFO    : Parsing the specification
18-05-02 16:51 INFO    : Checking the well-formedness of the specification
18-05-02 16:51 INFO    : Checking convergence
18-05-02 16:51 INFO    : Checking safety
18-05-02 16:51 INFO    : The specification is safe!!!
18-05-03 10:38 INFO    : ************ sample ***************
18-05-03 10:38 INFO    : Checking the syntax
18-05-03 10:38 INFO    : Parsing the specification
18-05-03 10:38 INFO    : Checking the well-formedness of the specification
18-05-03 10:38 ERROR   : All global variables which are not the basic datatype needs a greater than or equal to function defined

18-05-03 10:38 INFO    : ************ sample ***************
18-05-03 10:38 INFO    : Checking the syntax
18-05-03 10:38 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/sample.bpl(6,3): Error: undeclared identifier: one
results/sample.bpl(6,10): Error: undeclared identifier: two
2 name resolution errors detected in results/sample.bpl


18-05-03 10:39 INFO    : ************ sample ***************
18-05-03 10:39 INFO    : Checking the syntax
18-05-03 10:39 INFO    : Parsing the specification
18-05-03 10:39 INFO    : Checking the well-formedness of the specification
18-05-03 10:39 INFO    : Checking convergence
18-05-03 10:39 ERROR   : monotonicity_inc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_counter(counter,old(counter));
The value of parameters and variables are ::


18-05-03 10:39 INFO    : ************ sample ***************
18-05-03 10:39 INFO    : Checking the syntax
18-05-03 10:39 ERROR   : sample::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (counter == old(counter) + 1);


18-05-03 10:39 INFO    : ************ sample ***************
18-05-03 10:39 INFO    : Checking the syntax
18-05-03 10:39 INFO    : Parsing the specification
18-05-03 10:39 INFO    : Checking the well-formedness of the specification
18-05-03 10:39 INFO    : Checking convergence
18-05-03 10:39 ERROR   : lub_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(counter,old(counter)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(counter,_counter1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _counter:int::gteq_counter(_counter,old(counter)) && gteq_counter(_counter,_counter1) ==> gteq_counter(_counter,counter));
The value of parameters and variables are ::


18-05-03 10:40 INFO    : ************ sample ***************
18-05-03 10:40 INFO    : Checking the syntax
18-05-03 10:40 INFO    : Parsing the specification
18-05-03 10:40 INFO    : Checking the well-formedness of the specification
18-05-03 10:40 INFO    : Checking convergence
18-05-03 10:40 ERROR   : lub_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(counter,old(counter)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(counter,_counter1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _counter:int::gteq_counter(_counter,old(counter)) && gteq_counter(_counter,_counter1) ==> gteq_counter(_counter,counter));
The value of parameters and variables are ::


18-05-03 10:41 INFO    : ************ sample ***************
18-05-03 10:41 INFO    : Checking the syntax
18-05-03 10:41 INFO    : Parsing the specification
18-05-03 10:41 INFO    : Checking the well-formedness of the specification
18-05-03 10:41 INFO    : Checking convergence
18-05-03 10:41 ERROR   : lub_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _counter:int::gteq_counter(_counter,old(counter)) && gteq_counter(_counter,_counter1) ==> gteq_counter(_counter,counter));
The value of parameters and variables are ::


18-05-03 10:42 INFO    : ************ sample ***************
18-05-03 10:42 INFO    : Checking the syntax
18-05-03 10:42 INFO    : Parsing the specification
18-05-03 10:42 INFO    : Checking the well-formedness of the specification
18-05-03 10:42 INFO    : Checking convergence
18-05-03 10:42 INFO    : Checking safety
18-05-03 10:42 INFO    : The specification is safe!!!
18-05-03 11:06 INFO    : ************ book_store_complete ***************
18-05-03 11:06 INFO    : Checking the syntax
18-05-03 11:06 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(90,90): Error: undeclared identifier: incoming
results/book_store_complete.bpl(90,163): Error: undeclared identifier: incoming
results/book_store_complete.bpl(91,88): Error: undeclared identifier: incoming
results/book_store_complete.bpl(91,172): Error: undeclared identifier: incoming
results/book_store_complete.bpl(91,261): Error: undeclared identifier: incoming
results/book_store_complete.bpl(91,352): Error: undeclared identifier: incoming
results/book_store_complete.bpl(91,460): Error: undeclared identifier: incoming
results/book_store_complete.bpl(92,59): Error: undeclared identifier: incoming
8 name resolution errors detected in results/book_store_complete.bpl


18-05-03 11:07 INFO    : ************ book_store_complete ***************
18-05-03 11:07 INFO    : Checking the syntax
18-05-03 11:07 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(145,43): Error: invalid argument types ([ReplicaID]int and int) to binary operator +
1 type checking errors detected in results/book_store_complete.bpl



18-05-03 11:11 INFO    : ************ book_store_complete ***************
18-05-03 11:11 INFO    : Checking the syntax
18-05-03 11:11 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall o:OrderId :: (o == id ==> (UserOrders[o][created] == old(UserOrders)[o][created] && UserOrders[o][user] == old(UserOrders)[o][user] && UserOrders[o][placed] == false && UserOrders[o][cancelled] == false && UserOrders[o][processed] == false && (forall b:ISBN :: (b == book ==> UserOrders[o][items][b] == qty) && (b != book ==> UserOrders[o][items][b] == old(UserOrders)[o][items][b])))) && (o != id ==> (UserOrders[o][created] == old(UserOrders)[o][created] && UserOrders[o][user] == old(UserOrders)[o][user] && UserOrders[o][placed] == old(UserOrders)[o][placed] && UserOrders[o][cancelled] == old(UserOrders)[o][cancelled] && UserOrders[o][processed] == old(UserOrders)[o][processed] && (forall b:ISBN :: UserOrders[o][items][b] == old(UserOrders)[o][items][b]))));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-03 11:13 INFO    : ************ book_store_complete ***************
18-05-03 11:13 INFO    : Checking the syntax
18-05-03 11:13 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall o:OrderId :: (o == id ==> (UserOrders[o][created] == old(UserOrders)[o][created] && UserOrders[o][user] == old(UserOrders)[o][user] && UserOrders[o][placed] == false && UserOrders[o][cancelled] == false && UserOrders[o][processed] == false && (forall b:ISBN :: (b == book ==> UserOrders[o][items][b] == qty) && (b != book ==> UserOrders[o][items][b] == old(UserOrders)[o][items][b])))) && (o != id ==> (UserOrders[o][created] == old(UserOrders)[o][created] && UserOrders[o][user] == old(UserOrders)[o][user] && UserOrders[o][placed] == old(UserOrders)[o][placed] && UserOrders[o][cancelled] == old(UserOrders)[o][cancelled] && UserOrders[o][processed] == old(UserOrders)[o][processed] && (forall b:ISBN :: UserOrders[o][items][b] == old(UserOrders)[o][items][b]))));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-03 11:15 INFO    : ************ book_store_complete ***************
18-05-03 11:15 INFO    : Checking the syntax
18-05-03 11:15 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-03 11:25 INFO    : ************ book_store_complete ***************
18-05-03 11:25 INFO    : Checking the syntax
18-05-03 11:25 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:17 INFO    : ************ book_store_complete ***************
18-05-16 10:17 INFO    : Checking the syntax
18-05-16 10:17 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(141,2): Error: undeclared identifier: b
results/book_store_complete.bpl(142,9): Error: undeclared identifier: b
results/book_store_complete.bpl(144,14): Error: undeclared identifier: b
results/book_store_complete.bpl(144,37): Error: undeclared identifier: b
results/book_store_complete.bpl(144,71): Error: undeclared identifier: b
results/book_store_complete.bpl(145,4): Error: undeclared identifier: b
results/book_store_complete.bpl(145,9): Error: undeclared identifier: b
results/book_store_complete.bpl(142,9): Error: undeclared identifier: b
8 name resolution errors detected in results/book_store_complete.bpl


18-05-16 10:17 INFO    : ************ book_store_complete ***************
18-05-16 10:17 INFO    : Checking the syntax
18-05-16 10:17 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (b < nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:21 INFO    : ************ book_store_complete ***************
18-05-16 10:21 INFO    : Checking the syntax
18-05-16 10:21 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (b < nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (b > 0 && b < nb) ==> ((r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:22 INFO    : ************ book_store_complete ***************
18-05-16 10:22 INFO    : Checking the syntax
18-05-16 10:22 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (b <= nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (b >= 0 && b <= nb) ==> ((r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:24 INFO    : ************ book_store_complete ***************
18-05-16 10:24 INFO    : Checking the syntax
18-05-16 10:24 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (b <= nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN :: (b >= 0 && b <= nb) ==> (BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]));
A postcondition might not hold on this return path.
while (b <= nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (b >= 0 && b <= nb) ==> ((r == me ==> (BookStore[b][N][r] == old(BookStore)[b][N][r] + UserOrders[id][items][b])) && (r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:24 INFO    : ************ book_store_complete ***************
18-05-16 10:24 INFO    : Checking the syntax
18-05-16 10:24 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (b <= nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN :: (b >= 0 && b <= nb) ==> (BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]));
A postcondition might not hold on this return path.
while (b <= nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN, r:ReplicaID :: (b >= 0 && b <= nb) ==> ((r != me ==> BookStore[b][N][r] == old(BookStore)[b][N][r]) && BookStore[b][P][r] == old(BookStore)[b][P][r]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:48 INFO    : ************ book_store_complete ***************
18-05-16 10:48 INFO    : Checking the syntax
18-05-16 10:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(149,142): error: ";" expected
1 parse errors detected in results/book_store_complete.bpl



18-05-16 10:48 INFO    : ************ book_store_complete ***************
18-05-16 10:48 INFO    : Checking the syntax
18-05-16 10:48 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(147,32): Error: more than one declaration of variable name: b
results/book_store_complete.bpl(148,32): Error: more than one declaration of variable name: b
results/book_store_complete.bpl(149,32): Error: more than one declaration of variable name: b
3 name resolution errors detected in results/book_store_complete.bpl


18-05-16 10:50 INFO    : ************ book_store_complete ***************
18-05-16 10:50 INFO    : Checking the syntax
18-05-16 10:50 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/book_store_complete.bpl(144,2): Error: undeclared identifier: book
results/book_store_complete.bpl(146,18): Error: undeclared identifier: book
results/book_store_complete.bpl(146,26): Error: undeclared identifier: book
results/book_store_complete.bpl(147,32): Error: more than one declaration of variable name: b
results/book_store_complete.bpl(148,32): Error: more than one declaration of variable name: b
results/book_store_complete.bpl(149,32): Error: more than one declaration of variable name: b
results/book_store_complete.bpl(149,58): Error: undeclared identifier: book
results/book_store_complete.bpl(145,9): Error: undeclared identifier: book
results/book_store_complete.bpl(151,14): Error: undeclared identifier: book
results/book_store_complete.bpl(151,40): Error: undeclared identifier: book
results/book_store_complete.bpl(151,77): Error: undeclared identifier: book
results/book_store_complete.bpl(152,4): Error: undeclared identifier: book
results/book_store_complete.bpl(152,12): Error: undeclared identifier: book
results/book_store_complete.bpl(145,9): Error: undeclared identifier: book
14 name resolution errors detected in results/book_store_complete.bpl


18-05-16 10:50 INFO    : ************ book_store_complete ***************
18-05-16 10:50 INFO    : Checking the syntax
18-05-16 10:50 ERROR   : book_store_complete::::::
This loop invariant might not be maintained by the loop.
invariant (0 <= book && book <= nb);
This loop invariant might not hold on entry.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b <= book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
This loop invariant might not be maintained by the loop.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b <= book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:53 INFO    : ************ book_store_complete ***************
18-05-16 10:53 INFO    : Checking the syntax
18-05-16 10:53 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (book < nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN :: (b >= 0 && b <= nb) ==> (BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]));
This loop invariant might not hold on entry.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b <= book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
This loop invariant might not be maintained by the loop.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b <= book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-16 10:54 INFO    : ************ book_store_complete ***************
18-05-16 10:54 INFO    : Checking the syntax
18-05-16 10:54 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (book < nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN :: (b >= 0 && b <= nb) ==> (BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]));
This loop invariant might not be maintained by the loop.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b < book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-18 09:59 INFO    : ************ book_store_complete ***************
18-05-18 09:59 INFO    : Checking the syntax
18-05-18 09:59 ERROR   : book_store_complete::::::
A postcondition might not hold on this return path.
while (book < nb)
This is the postcondition that might not hold.
ensures (forall b:ISBN :: (b >= 0 && b <= nb) ==> (BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]));
This loop invariant might not be maintained by the loop.
invariant(forall r:ReplicaID, b:ISBN :: (0 <= b && b < book) ==> BookStore[b][N][me] == old(BookStore)[b][N][me] + UserOrders[id][items][b]);
This assertion might not hold.
assert (BookStore[book][N][me] == (old(BookStore)[book][N][me] + UserOrders[id][items][book]));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall u:UserId :: (u == user ==> Users[user] == true) && (u != user ==> Users[user] == old(Users)[user]));


18-05-28 10:48 INFO    : ************ token ***************
18-05-28 10:48 INFO    : Checking the syntax
18-05-28 10:48 INFO    : Parsing the specification
18-05-28 10:48 INFO    : Checking the well-formedness of the specification
18-05-28 10:48 INFO    : Checking convergence
18-05-28 10:48 INFO    : Checking safety
18-05-28 10:48 INFO    : The specification is safe!!!
18-05-28 12:07 INFO    : ************ token ***************
18-05-28 12:07 INFO    : Checking the syntax
18-05-28 12:07 INFO    : Parsing the specification
18-05-28 12:07 INFO    : Checking the well-formedness of the specification
18-05-28 12:07 INFO    : Checking convergence
18-05-28 12:07 INFO    : Checking safety
18-05-28 12:07 ERROR   : can only concatenate list (not "Procedure") to list

18-05-28 12:07 INFO    : ************ token ***************
18-05-28 12:07 INFO    : Checking the syntax
18-05-28 12:07 INFO    : Parsing the specification
18-05-28 12:07 INFO    : Checking the well-formedness of the specification
18-05-28 12:07 INFO    : Checking convergence
18-05-28 12:07 INFO    : Checking safety
18-05-28 12:07 ERROR   : stability_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (t == t1 ==> (forall r:ReplicaId :: V[r] == V1[r])) && (V[me] == 1 ==> t >= t1);
The value of parameters and variables are ::

18-05-28 12:07 ERROR   : 

18-05-28 12:20 INFO    : ************ token ***************
18-05-28 12:20 INFO    : Checking the syntax
18-05-28 12:20 INFO    : Parsing the specification
18-05-28 12:20 INFO    : Checking the well-formedness of the specification
18-05-28 12:20 INFO    : Checking convergence
18-05-28 12:20 INFO    : Checking safety
18-05-28 12:20 INFO    : The specification is safe!!!
18-05-28 12:29 INFO    : ************ bank_scaled_down ***************
18-05-28 12:29 INFO    : Checking the syntax
18-05-28 12:29 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t]));


18-05-28 12:48 INFO    : ************ token ***************
18-05-28 12:48 INFO    : Checking the syntax
18-05-28 12:48 INFO    : Parsing the specification
18-05-28 12:48 INFO    : Checking the well-formedness of the specification
18-05-28 12:48 INFO    : Checking convergence
18-05-28 12:48 INFO    : Checking safety
18-05-28 12:48 INFO    : The specification is safe!!!
18-05-28 12:49 INFO    : ************ token ***************
18-05-28 12:49 INFO    : Checking the syntax
18-05-28 12:49 INFO    : Parsing the specification
18-05-28 12:49 INFO    : Checking the well-formedness of the specification
18-05-28 12:49 INFO    : Checking convergence
18-05-28 12:49 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_V(t,V,_t1,_V1));
The value of parameters and variables are ::


18-05-28 12:49 INFO    : ************ token ***************
18-05-28 12:49 INFO    : Checking the syntax
18-05-28 12:49 INFO    : Parsing the specification
18-05-28 12:49 INFO    : Checking the well-formedness of the specification
18-05-28 12:49 INFO    : Checking convergence
18-05-28 12:49 INFO    : Checking safety
18-05-28 12:49 ERROR   : stability_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (t == t1 ==> (forall r:ReplicaId :: V[r] == V1[r]));
The value of parameters and variables are ::

18-05-28 12:49 ERROR   : 

18-05-28 12:51 INFO    : ************ token ***************
18-05-28 12:51 INFO    : Checking the syntax
18-05-28 12:51 INFO    : Parsing the specification
18-05-28 12:51 INFO    : Checking the well-formedness of the specification
18-05-28 12:51 INFO    : Checking convergence
18-05-28 12:51 INFO    : Checking safety
18-05-28 12:51 INFO    : The specification is safe!!!
18-05-28 12:53 INFO    : ************ token ***************
18-05-28 12:53 INFO    : Checking the syntax
18-05-28 12:53 INFO    : Parsing the specification
18-05-28 12:53 INFO    : Checking the well-formedness of the specification
18-05-28 12:53 INFO    : Checking convergence
18-05-28 12:53 INFO    : Checking safety
18-05-28 12:53 INFO    : The specification is safe!!!
18-05-28 12:54 INFO    : ************ token ***************
18-05-28 12:54 INFO    : Checking the syntax
18-05-28 12:54 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-05-28 12:54 INFO    : ************ token ***************
18-05-28 12:54 INFO    : Checking the syntax
18-05-28 12:54 INFO    : Parsing the specification
18-05-28 12:54 INFO    : Checking the well-formedness of the specification
18-05-28 12:54 INFO    : Checking convergence
18-05-28 12:54 ERROR   : monotonicity_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_V(t,V,old(t),old(V));
The value of parameters and variables are ::


18-05-28 12:54 INFO    : ************ token ***************
18-05-28 12:54 INFO    : Checking the syntax
18-05-28 12:54 INFO    : Parsing the specification
18-05-28 12:54 INFO    : Checking the well-formedness of the specification
18-05-28 12:54 INFO    : Checking convergence
18-05-28 12:54 INFO    : Checking safety
18-05-28 12:54 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-28 12:55 ERROR   : 

18-05-28 12:55 INFO    : ************ token ***************
18-05-28 12:55 INFO    : Checking the syntax
18-05-28 12:55 INFO    : Parsing the specification
18-05-28 12:55 INFO    : Checking the well-formedness of the specification
18-05-28 12:55 INFO    : Checking convergence
18-05-28 12:55 INFO    : Checking safety
18-05-28 12:55 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-28 12:55 ERROR   : 

18-05-28 12:55 INFO    : ************ token ***************
18-05-28 12:55 INFO    : Checking the syntax
18-05-28 12:55 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures t > old(t);


18-05-28 12:56 INFO    : ************ token ***************
18-05-28 12:56 INFO    : Checking the syntax
18-05-28 12:56 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-05-28 12:56 INFO    : ************ token ***************
18-05-28 12:56 INFO    : Checking the syntax
18-05-28 12:56 INFO    : Parsing the specification
18-05-28 12:56 INFO    : Checking the well-formedness of the specification
18-05-28 12:56 INFO    : Checking convergence
18-05-28 12:56 INFO    : Checking safety
18-05-28 12:56 ERROR   : safety_transfer::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(V,t);
The value of parameters and variables are ::

18-05-28 12:56 ERROR   : 

18-05-28 12:56 INFO    : ************ token ***************
18-05-28 12:56 INFO    : Checking the syntax
18-05-28 12:57 INFO    : Parsing the specification
18-05-28 12:57 INFO    : Checking the well-formedness of the specification
18-05-28 12:57 INFO    : Checking convergence
18-05-28 12:57 INFO    : Checking safety
18-05-28 12:57 INFO    : The specification is safe!!!
18-05-29 12:07 INFO    : ************ token ***************
18-05-29 12:07 INFO    : Checking the syntax
18-05-29 12:07 INFO    : Parsing the specification
18-05-29 12:07 INFO    : Checking the well-formedness of the specification
18-05-29 12:07 INFO    : Checking convergence
18-05-29 12:07 INFO    : Checking safety
18-05-29 12:07 INFO    : The specification is safe!!!
18-05-30 11:43 INFO    : ************ token ***************
18-05-30 11:43 INFO    : Checking the syntax
18-05-30 11:43 INFO    : Parsing the specification
18-05-30 11:43 INFO    : Checking the well-formedness of the specification
18-05-30 11:43 INFO    : Checking convergence
18-05-30 11:43 INFO    : Checking safety
18-05-30 11:43 INFO    : The specification is safe!!!
18-06-04 16:52 INFO    : ************ token ***************
18-06-04 16:52 INFO    : Checking the syntax
18-06-04 16:52 INFO    : Parsing the specification
18-06-04 16:52 INFO    : Checking the well-formedness of the specification
18-06-04 16:52 INFO    : Checking convergence
18-06-04 16:52 INFO    : Checking safety
18-06-04 16:52 INFO    : The specification is safe!!!
18-06-07 10:39 INFO    : ************ token ***************
18-06-07 10:39 INFO    : Checking the syntax
18-06-07 10:39 INFO    : Parsing the specification
18-06-07 10:39 INFO    : Checking the well-formedness of the specification
18-06-07 10:39 INFO    : Checking convergence
18-06-07 10:39 INFO    : Checking safety
18-06-07 10:39 INFO    : The specification is safe!!!
18-06-07 08:58 INFO    : ************ token ***************
18-06-07 08:58 INFO    : Checking the syntax
18-06-07 08:58 ERROR   : 

18-06-07 09:54 INFO    : ************ token ***************
18-06-07 09:54 INFO    : Checking the syntax
18-06-07 09:54 INFO    : Parsing the specification
18-06-07 09:54 INFO    : Checking the well-formedness of the specification
18-06-07 09:54 INFO    : Checking convergence
18-06-07 09:54 INFO    : Checking safety
18-06-07 09:54 INFO    : The specification is safe!!!
18-06-07 10:17 INFO    : ************ token ***************
18-06-07 10:17 INFO    : Checking the syntax
18-06-07 10:17 INFO    : Parsing the specification
18-06-07 10:17 INFO    : Checking the well-formedness of the specification
18-06-07 10:17 INFO    : Checking convergence
18-06-07 10:17 INFO    : Checking monotonicity for procedure transfer
18-06-07 10:17 INFO    : Checking LUB properties of mergeprocedure
18-06-07 10:17 INFO    : Checking safety
18-06-07 10:17 INFO    : Checking whether merge upholds the invariant
18-06-07 10:17 INFO    : Checking whether transfer upholds the invariant
18-06-07 10:17 INFO    : Checking whether transfer upholds the precondition of merge
18-06-07 10:17 INFO    : Checking whether merge upholds the precondition of itself
18-06-07 10:17 INFO    : The specification is safe!!!
18-06-07 10:52 INFO    : ************ token ***************
18-06-07 10:52 INFO    : Checking the syntax
18-06-07 10:52 INFO    : Parsing the specification
18-06-07 10:52 INFO    : Checking the well-formedness of the specification
18-06-07 10:52 INFO    : Checking convergence
18-06-07 10:52 INFO    : Checking monotonicity for procedure transfer
18-06-07 10:52 INFO    : Checking LUB properties of mergeprocedure
18-06-07 10:52 INFO    : Checking safety
18-06-07 10:52 INFO    : Checking whether merge upholds the invariant
18-06-07 10:52 INFO    : Checking whether transfer upholds the invariant
18-06-07 10:52 INFO    : Checking whether transfer upholds the precondition of merge
18-06-07 10:52 INFO    : Checking whether merge upholds the precondition of itself
18-06-07 10:52 INFO    : The specification is safe!!!
18-06-07 10:55 INFO    : ************ token ***************
18-06-07 10:55 INFO    : Checking the syntax
18-06-07 10:55 INFO    : Parsing the specification
18-06-07 10:55 INFO    : Checking the well-formedness of the specification
18-06-07 10:55 INFO    : Checking convergence
18-06-07 10:55 INFO    : Checking monotonicity for procedure transfer
18-06-07 10:55 INFO    : Checking LUB properties of mergeprocedure
18-06-07 10:56 INFO    : Checking safety
18-06-07 10:56 INFO    : Checking whether merge upholds the invariant
18-06-07 10:56 INFO    : Checking whether transfer upholds the invariant
18-06-07 10:56 INFO    : Checking whether transfer upholds the precondition of merge
18-06-07 10:56 INFO    : Checking whether merge upholds the precondition of itself
18-06-07 10:56 INFO    : The specification is safe!!!
18-06-07 10:56 INFO    : ************ token ***************
18-06-07 10:56 INFO    : Checking the syntax
18-06-07 10:56 INFO    : Parsing the specification
18-06-07 10:56 INFO    : Checking the well-formedness of the specification
18-06-07 10:56 INFO    : Checking convergence
18-06-07 10:56 INFO    : Checking monotonicity for procedure transfer
18-06-07 10:56 INFO    : Checking LUB properties of mergeprocedure
18-06-07 10:56 INFO    : Checking safety
18-06-07 10:56 INFO    : Checking whether merge upholds the invariant
18-06-07 10:57 INFO    : Checking whether transfer upholds the invariant
18-06-07 10:57 INFO    : Checking whether transfer upholds the precondition of merge
18-06-07 10:57 INFO    : Checking whether merge upholds the precondition of itself
18-06-07 10:57 INFO    : The specification is safe!!!
18-07-24 12:43 INFO    : ************ bank_scaled_down ***************
18-07-24 12:43 INFO    : Checking the syntax
18-07-24 12:43 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t]));


18-07-24 12:44 INFO    : ************ bank_scaled_down ***************
18-07-24 12:44 INFO    : Checking the syntax
18-07-24 12:44 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_scaled_down.bpl(52,64): error: invalid UnaryExpression
1 parse errors detected in results/bank_scaled_down.bpl



18-07-24 12:44 INFO    : ************ bank_scaled_down ***************
18-07-24 12:44 INFO    : Checking the syntax
18-07-24 12:44 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: (c >= 0 && c < 3) ==> (balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t])));


18-07-24 12:45 INFO    : ************ bank_scaled_down ***************
18-07-24 12:45 INFO    : Checking the syntax
18-07-24 12:45 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: (c >= 0 && c < 3 && r >= 0 && r < 3) ==> (balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t])));


18-07-24 12:45 INFO    : ************ bank_scaled_down ***************
18-07-24 12:45 INFO    : Checking the syntax
18-07-24 12:45 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: (c >= 0 && c < 3 && r >= 0 && r < 3 && (t == w || t == d)) ==> (balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t])));


18-07-24 12:48 INFO    : ************ bank_scaled_down ***************
18-07-24 12:48 INFO    : Checking the syntax
18-07-24 12:48 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn :: (c >= 0 && c < 3 && r >= 0 && r < 3 && (t == w || t == d)) ==> (balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t])));


18-07-24 12:49 INFO    : ************ bank_scaled_down ***************
18-07-24 12:49 INFO    : Checking the syntax
18-07-24 12:49 INFO    : Parsing the specification
18-07-24 12:49 ERROR   : substring not found

18-07-24 12:51 INFO    : ************ bank_scaled_down ***************
18-07-24 12:51 INFO    : Checking the syntax
18-07-24 12:51 INFO    : Parsing the specification
18-07-24 12:51 INFO    : Checking the well-formedness of the specification
18-07-24 12:51 INFO    : Checking convergence
18-07-24 12:51 INFO    : Checking monotonicity for procedure deposit
18-07-24 12:51 INFO    : Checking monotonicity for procedure withdraw
18-07-24 12:51 INFO    : Checking LUB properties of merge_procprocedure
18-07-24 12:51 ERROR   : lub_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(balances,old(balances)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(balances,_balances1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _balances:[Client][ReplicaID][Txn]int::gteq_counter(_balances,old(balances)) && gteq_counter(_balances,_balances1) ==> gteq_counter(_balances,balances));
The value of parameters and variables are ::


18-07-24 12:52 INFO    : ************ bank_scaled_down ***************
18-07-24 12:52 INFO    : Checking the syntax
18-07-24 12:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_scaled_down.bpl(18,75): Error: undeclared identifier: t
results/bank_scaled_down.bpl(18,85): Error: undeclared identifier: t
2 name resolution errors detected in results/bank_scaled_down.bpl


18-07-24 12:52 INFO    : ************ bank_scaled_down ***************
18-07-24 12:52 INFO    : Checking the syntax
18-07-24 12:52 INFO    : Parsing the specification
18-07-24 12:52 INFO    : Checking the well-formedness of the specification
18-07-24 12:52 INFO    : Checking convergence
18-07-24 12:52 INFO    : Checking monotonicity for procedure deposit
18-07-24 12:52 INFO    : Checking monotonicity for procedure withdraw
18-07-24 12:52 INFO    : Checking LUB properties of merge_procprocedure
18-07-24 12:52 INFO    : Checking safety
18-07-24 12:52 INFO    : Checking whether deposit upholds the invariant
18-07-24 12:52 INFO    : Checking whether withdraw upholds the invariant
18-07-24 12:52 INFO    : Checking whether merge_proc upholds the invariant
18-07-24 12:52 ERROR   : safety_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(balances);
The value of parameters and variables are ::

18-07-24 12:52 INFO    : Checking whether deposit upholds the precondition of merge
18-07-24 12:52 INFO    : Checking whether withdraw upholds the precondition of merge
18-07-24 12:52 INFO    : Checking whether merge_proc upholds the precondition of itself
18-07-24 12:52 ERROR   : 

18-07-24 12:53 INFO    : ************ bank_scaled_down ***************
18-07-24 12:53 INFO    : Checking the syntax
18-07-24 12:53 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_scaled_down.bpl(23,77): error: invalid UnaryExpression
1 parse errors detected in results/bank_scaled_down.bpl



18-07-24 12:53 INFO    : ************ bank_scaled_down ***************
18-07-24 12:53 INFO    : Checking the syntax
18-07-24 12:53 INFO    : Parsing the specification
18-07-24 12:53 INFO    : Checking the well-formedness of the specification
18-07-24 12:53 INFO    : Checking convergence
18-07-24 12:53 INFO    : Checking monotonicity for procedure deposit
18-07-24 12:53 INFO    : Checking monotonicity for procedure withdraw
18-07-24 12:53 INFO    : Checking LUB properties of merge_procprocedure
18-07-24 12:53 INFO    : Checking safety
18-07-24 12:53 INFO    : Checking whether deposit upholds the invariant
18-07-24 12:54 INFO    : Checking whether withdraw upholds the invariant
18-07-24 12:54 INFO    : Checking whether merge_proc upholds the invariant
18-07-24 12:54 INFO    : Checking whether deposit upholds the precondition of merge
18-07-24 12:54 INFO    : Checking whether withdraw upholds the precondition of merge
18-07-24 12:54 INFO    : Checking whether merge_proc upholds the precondition of itself
18-07-24 12:54 INFO    : The specification is safe!!!
18-07-24 12:54 INFO    : ************ bank_scaled_down ***************
18-07-24 12:54 INFO    : Checking the syntax
18-07-24 12:54 ERROR   : bank_scaled_down::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID, t:Txn ::  (balances[c][r][t] == max(old(balances)[c][r][t], balances1[c][r][t])));


18-07-24 12:55 INFO    : ************ bank_scaled_down ***************
18-07-24 12:55 INFO    : Checking the syntax
18-07-24 12:55 INFO    : Parsing the specification
18-07-24 12:55 INFO    : Checking the well-formedness of the specification
18-07-24 12:55 INFO    : Checking convergence
18-07-24 12:55 INFO    : Checking monotonicity for procedure deposit
18-07-24 12:55 INFO    : Checking monotonicity for procedure withdraw
18-07-24 12:55 INFO    : Checking LUB properties of merge_procprocedure
18-07-24 12:55 INFO    : Checking safety
18-07-24 12:55 INFO    : Checking whether deposit upholds the invariant
18-07-24 12:55 INFO    : Checking whether withdraw upholds the invariant
18-07-24 12:55 INFO    : Checking whether merge_proc upholds the invariant
18-07-24 12:55 INFO    : Checking whether deposit upholds the precondition of merge
18-07-24 12:55 INFO    : Checking whether withdraw upholds the precondition of merge
18-07-24 12:55 INFO    : Checking whether merge_proc upholds the precondition of itself
18-07-24 12:55 INFO    : The specification is safe!!!
18-07-24 13:05 INFO    : ************ token ***************
18-07-24 13:05 INFO    : Checking the syntax
18-07-24 13:05 INFO    : Parsing the specification
18-07-24 13:05 INFO    : Checking the well-formedness of the specification
18-07-24 13:05 INFO    : Checking convergence
18-07-24 13:05 INFO    : Checking monotonicity for procedure transfer
18-07-24 13:05 INFO    : Checking LUB properties of mergeprocedure
18-07-24 13:05 INFO    : Checking safety
18-07-24 13:05 INFO    : Checking whether transfer upholds the invariant
18-07-24 13:05 INFO    : Checking whether merge upholds the invariant
18-07-24 13:05 INFO    : Checking whether transfer upholds the precondition of merge
18-07-24 13:05 INFO    : Checking whether merge upholds the precondition of itself
18-07-24 13:06 INFO    : The specification is safe!!!
18-07-31 10:07 INFO    : ************ auction ***************
18-07-31 10:07 INFO    : Checking the syntax
18-07-31 10:07 INFO    : Parsing the specification
18-07-31 10:07 INFO    : Checking the well-formedness of the specification
18-07-31 10:07 ERROR   : Not able to resolve the corresponding global variable for parameter

18-07-31 10:12 INFO    : ************ auction ***************
18-07-31 10:12 INFO    : Checking the syntax
18-07-31 10:12 INFO    : Parsing the specification
18-07-31 10:12 INFO    : Checking the well-formedness of the specification
18-07-31 10:12 INFO    : Checking convergence
18-07-31 10:12 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 10:12 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_registerSeller.bpl(85,8): Error: undeclared identifier: _sellers
1 name resolution errors detected in results/monotonicity_registerSeller.bpl


18-07-31 10:15 INFO    : ************ auction ***************
18-07-31 10:15 INFO    : Checking the syntax
18-07-31 10:15 INFO    : Parsing the specification
18-07-31 10:15 INFO    : Checking the well-formedness of the specification
18-07-31 10:15 INFO    : Checking convergence
18-07-31 10:15 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 10:15 INFO    : Checking LUB properties of mergeprocedure
18-07-31 10:15 INFO    : Checking safety
18-07-31 10:15 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 10:16 ERROR   : safety_registerSeller::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 10:16 INFO    : Checking whether merge upholds the invariant
18-07-31 10:16 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 10:16 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 10:16 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 10:16 ERROR   : 

18-07-31 11:51 INFO    : ************ auction ***************
18-07-31 11:51 INFO    : Checking the syntax
18-07-31 11:51 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(60,33): Error: undeclared identifier: promoters
1 name resolution errors detected in results/auction.bpl


18-07-31 11:51 INFO    : ************ auction ***************
18-07-31 11:51 INFO    : Checking the syntax
18-07-31 11:51 INFO    : Parsing the specification
18-07-31 11:51 INFO    : Checking the well-formedness of the specification
18-07-31 11:51 INFO    : Checking convergence
18-07-31 11:51 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 11:51 INFO    : Checking LUB properties of mergeprocedure
18-07-31 11:51 INFO    : Checking safety
18-07-31 11:51 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 11:51 ERROR   : safety_registerSeller::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 11:51 INFO    : Checking whether merge upholds the invariant
18-07-31 11:51 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 11:51 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 11:51 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 11:51 ERROR   : 

18-07-31 14:32 INFO    : ************ auction ***************
18-07-31 14:32 INFO    : Checking the syntax
18-07-31 14:32 INFO    : Parsing the specification
18-07-31 14:32 INFO    : Checking the well-formedness of the specification
18-07-31 14:32 INFO    : Checking convergence
18-07-31 14:32 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 14:32 INFO    : Checking LUB properties of mergeprocedure
18-07-31 14:32 INFO    : Checking safety
18-07-31 14:32 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 14:32 ERROR   : safety_registerSeller::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:32 INFO    : Checking whether merge upholds the invariant
18-07-31 14:32 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:32 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 14:32 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 14:32 ERROR   : 

18-07-31 14:32 INFO    : ************ auction ***************
18-07-31 14:32 INFO    : Checking the syntax
18-07-31 14:32 INFO    : Parsing the specification
18-07-31 14:32 INFO    : Checking the well-formedness of the specification
18-07-31 14:32 INFO    : Checking convergence
18-07-31 14:32 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 14:32 INFO    : Checking LUB properties of mergeprocedure
18-07-31 14:32 INFO    : Checking safety
18-07-31 14:32 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 14:32 ERROR   : safety_registerSeller::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:32 INFO    : Checking whether merge upholds the invariant
18-07-31 14:32 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:32 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 14:33 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 14:33 ERROR   : 

18-07-31 14:33 INFO    : ************ auction ***************
18-07-31 14:33 INFO    : Checking the syntax
18-07-31 14:33 INFO    : Parsing the specification
18-07-31 14:33 INFO    : Checking the well-formedness of the specification
18-07-31 14:33 INFO    : Checking convergence
18-07-31 14:33 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 14:33 INFO    : Checking LUB properties of mergeprocedure
18-07-31 14:33 INFO    : Checking safety
18-07-31 14:33 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 14:33 ERROR   : safety_registerSeller::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:33 INFO    : Checking whether merge upholds the invariant
18-07-31 14:33 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures inv(buyers,sellers,products,auctions,promoter,state,winner,lots,bids,bid);
The value of parameters and variables are ::

18-07-31 14:33 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 14:33 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 14:33 ERROR   : 

18-07-31 14:36 INFO    : ************ auction ***************
18-07-31 14:36 INFO    : Checking the syntax
18-07-31 14:36 INFO    : Parsing the specification
18-07-31 14:36 INFO    : Checking the well-formedness of the specification
18-07-31 14:36 INFO    : Checking convergence
18-07-31 14:36 INFO    : Checking monotonicity for procedure registerSeller
18-07-31 14:36 INFO    : Checking LUB properties of mergeprocedure
18-07-31 14:36 INFO    : Checking safety
18-07-31 14:36 INFO    : Checking whether registerSeller upholds the invariant
18-07-31 14:36 INFO    : Checking whether merge upholds the invariant
18-07-31 14:36 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall s:UserId, p:ProductId :: products[p][s] ==> sellers[s]) && (forall a:AuctionId :: sellers[promoter[a]]) && (forall a:AuctionId :: winner[a] == null || buyers[winner[a]]) && (forall a:AuctionId, p:ProductId :: lots[a][p] ==> (exists s:UserId :: promoter[a] == s && products[p][s])) && (forall a:AuctionId, b:UserId :: bids[a][b] ==> (auctions[a] && buyers[b])) && (forall a:AuctionId :: state[a] == active ==> (exists p:ProductId :: lots[a][p])) && (forall a:AuctionId :: (state[a] == active || state[a] == prep) ==> winner[a] == null) && (forall a:AuctionId :: state[a] == closed ==> winner[a] != null && !(exists u:UserId :: bids[a][u] && bid[a][u] >= bid[a][winner[a]]));
The value of parameters and variables are ::

18-07-31 14:36 INFO    : Checking whether registerSeller upholds the precondition of merge
18-07-31 14:36 INFO    : Checking whether merge upholds the precondition of itself
18-07-31 14:36 ERROR   : 

18-09-03 07:41 INFO    : ************ auction ***************
18-09-03 07:41 INFO    : Checking the syntax
18-09-03 07:41 INFO    : Parsing the specification
18-09-03 07:41 INFO    : Checking the well-formedness of the specification
18-09-03 07:41 INFO    : Checking convergence
18-09-03 07:41 INFO    : Checking monotonicity for procedure registerSeller
18-09-03 07:41 INFO    : Checking LUB properties of mergeprocedure
18-09-03 07:41 INFO    : Checking safety
18-09-03 07:41 INFO    : Checking whether registerSeller upholds the invariant
18-09-03 07:41 INFO    : Checking whether merge upholds the invariant
18-09-03 07:41 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall s:UserId, p:ProductId :: products[p][s] ==> sellers[s]) && (forall a:AuctionId :: sellers[promoter[a]]) && (forall a:AuctionId :: winner[a] == null || buyers[winner[a]]) && (forall a:AuctionId, p:ProductId :: lots[a][p] ==> (exists s:UserId :: promoter[a] == s && products[p][s])) && (forall a:AuctionId, b:UserId :: bids[a][b] ==> (auctions[a] && buyers[b])) && (forall a:AuctionId :: state[a] == active ==> (exists p:ProductId :: lots[a][p])) && (forall a:AuctionId :: (state[a] == active || state[a] == prep) ==> winner[a] == null) && (forall a:AuctionId :: state[a] == closed ==> winner[a] != null && !(exists u:UserId :: bids[a][u] && bid[a][u] >= bid[a][winner[a]]));
The value of parameters and variables are ::

18-09-03 07:41 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-03 07:41 INFO    : Checking whether merge upholds the precondition of itself
18-09-03 07:42 ERROR   : 

18-09-05 14:34 INFO    : ************ bank_one_client ***************
18-09-05 14:34 INFO    : Checking the syntax
18-09-05 14:34 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] == max(old(balances[q][d]), balances1[q][d]));
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] == max(old(balances[q][w]), balances1[q][w]));


18-09-05 14:36 INFO    : ************ bank_one_client ***************
18-09-05 14:36 INFO    : Checking the syntax
18-09-05 14:36 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] == max(old(balances[q][d]), balances1[q][d]));
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] == max(old(balances[q][w]), balances1[q][w]));


18-09-05 14:37 INFO    : ************ bank_one_client ***************
18-09-05 14:37 INFO    : Checking the syntax
18-09-05 14:37 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances[q][d]) && balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances[q][w]) && balances[q][w] >= balances1[q][w]);


18-09-05 14:38 INFO    : ************ bank_one_client ***************
18-09-05 14:38 INFO    : Checking the syntax
18-09-05 14:38 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:39 INFO    : ************ bank_one_client ***************
18-09-05 14:39 INFO    : Checking the syntax
18-09-05 14:39 ERROR   : bank_one_client::::::
This loop invariant might not hold on entry.
invariant (forall q:int :: (0 <= q && q <= r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q <= r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This loop invariant might not hold on entry.
invariant (forall q:int :: (0 <= q && q <= r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q <= r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:41 INFO    : ************ bank_one_client ***************
18-09-05 14:41 INFO    : Checking the syntax
18-09-05 14:41 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);
This assertion might not hold.
assert (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);


18-09-05 14:41 INFO    : ************ bank_one_client ***************
18-09-05 14:41 INFO    : Checking the syntax
18-09-05 14:41 ERROR   : bank_one_client::::::
This assertion might not hold.
assert (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This assertion might not hold.
assert (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:42 INFO    : ************ bank_one_client ***************
18-09-05 14:42 INFO    : Checking the syntax
18-09-05 14:42 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (0 <= r && r < nr);
This assertion might not hold.
assert (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This assertion might not hold.
assert (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:47 INFO    : ************ bank_one_client ***************
18-09-05 14:47 INFO    : Checking the syntax
18-09-05 14:47 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:53 INFO    : ************ bank_one_client ***************
18-09-05 14:53 INFO    : Checking the syntax
18-09-05 14:53 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d] && balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:54 INFO    : ************ bank_one_client ***************
18-09-05 14:54 INFO    : Checking the syntax
18-09-05 14:54 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w] && balances[q][w] >= balances1[q][w]);


18-09-05 14:55 INFO    : ************ bank_one_client ***************
18-09-05 14:55 INFO    : Checking the syntax
18-09-05 14:55 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w]);


18-09-05 14:56 INFO    : ************ bank_one_client ***************
18-09-05 14:56 INFO    : Checking the syntax
18-09-05 14:56 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w]);


18-09-06 09:03 INFO    : ************ bank_one_client ***************
18-09-06 09:03 INFO    : Checking the syntax
18-09-06 09:03 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w]);


18-09-06 10:16 INFO    : ************ bank_one_client ***************
18-09-06 10:16 INFO    : Checking the syntax
18-09-06 10:16 ERROR   : bank_one_client::::::
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= old(balances)[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][d] >= balances1[q][d]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= old(balances)[q][w]);
This loop invariant might not be maintained by the loop.
invariant (forall q:int :: (0 <= q && q < r) ==> balances[q][w] >= balances1[q][w]);


18-09-06 10:18 INFO    : ************ bank_one_client ***************
18-09-06 10:18 INFO    : Checking the syntax
18-09-06 10:18 INFO    : Parsing the specification
18-09-06 10:18 INFO    : Checking the well-formedness of the specification
18-09-06 10:18 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-06 10:19 INFO    : ************ bank_one_client ***************
18-09-06 10:19 INFO    : Checking the syntax
18-09-06 10:19 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_one_client.bpl(67,69): error: ")" expected
1 parse errors detected in results/bank_one_client.bpl



18-09-06 10:20 INFO    : ************ bank_one_client ***************
18-09-06 10:20 INFO    : Checking the syntax
18-09-06 10:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_one_client.bpl(67,69): error: ")" expected
1 parse errors detected in results/bank_one_client.bpl



18-09-06 10:20 INFO    : ************ bank_one_client ***************
18-09-06 10:20 INFO    : Checking the syntax
18-09-06 10:20 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_one_client.bpl(67,69): error: ")" expected
1 parse errors detected in results/bank_one_client.bpl



18-09-06 10:22 INFO    : ************ bank_one_client ***************
18-09-06 10:22 INFO    : Checking the syntax
18-09-06 10:22 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank_one_client.bpl(67,69): error: ")" expected
1 parse errors detected in results/bank_one_client.bpl



18-09-06 10:23 INFO    : ************ bank_one_client ***************
18-09-06 10:23 INFO    : Checking the syntax
18-09-06 10:23 INFO    : Parsing the specification
18-09-06 10:23 INFO    : Checking the well-formedness of the specification
18-09-06 10:23 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-07 08:55 INFO    : ************ bank ***************
18-09-07 08:55 INFO    : Checking the syntax
18-09-07 08:55 ERROR   : bank::::::
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: c <= i ==> balances[i][j][d] == old(balances)[i][j][d] && balances[i][j][w] == old(balances)[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (i < c && i >= 0) ==> balances[i][j][w] == max(old(balances)[i][j][w], balances1[i][j][w]));
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][d] == old(balances)[i][j][d]);
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][w] == old(balances)[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (0 <= j && j < r) ==> balances[i][j][w] == max(old(balances)[i][j][w], balances1[i][j][w]));


18-09-07 08:58 INFO    : ************ bank ***************
18-09-07 08:58 INFO    : Checking the syntax
18-09-07 08:58 ERROR   : bank::::::
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: c <= i ==> balances[i][j][d] == old_balances[i][j][d] && balances[i][j][w] == old_balances[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (i < c && i >= 0) ==> balances[i][j][w] == max(old_balances[i][j][w], balances1[i][j][w]));
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][d] == old_balances[i][j][d]);
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][w] == old_balances[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (0 <= j && j < r) ==> balances[i][j][w] == max(old_balances[i][j][w], balances1[i][j][w]));


18-09-07 09:00 INFO    : ************ bank ***************
18-09-07 09:00 INFO    : Checking the syntax
18-09-07 09:00 ERROR   : bank::::::
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (c < i && c <= nc) ==> balances[i][j][d] == old_balances[i][j][d] && balances[i][j][w] == old_balances[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (0 <= i && i < c) ==> balances[i][j][w] == max(old_balances[i][j][w], balances1[i][j][w]));
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][d] == old_balances[i][j][d]);
This loop invariant might not hold on entry.
invariant (forall i, j:int :: (r < j && j <= nr) ==> balances[i][j][w] == old_balances[i][j][w]);
This loop invariant might not be maintained by the loop.
invariant (forall i, j:int :: (0 <= j && j < r) ==> balances[i][j][w] == max(old_balances[i][j][w], balances1[i][j][w]));


18-09-12 10:40 INFO    : ************ bank ***************
18-09-12 10:40 INFO    : Checking the syntax
18-09-12 10:40 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(67,74): Error: undeclared identifier: one
results/bank.bpl(67,95): Error: undeclared identifier: one
results/bank.bpl(67,107): Error: undeclared identifier: two
results/bank.bpl(68,75): Error: undeclared identifier: one
results/bank.bpl(68,92): Error: undeclared identifier: one
results/bank.bpl(72,20): Error: undeclared identifier: j
results/bank.bpl(72,25): Error: undeclared identifier: j
results/bank.bpl(74,53): Error: undeclared identifier: one
results/bank.bpl(74,74): Error: undeclared identifier: one
results/bank.bpl(74,86): Error: undeclared identifier: two
results/bank.bpl(75,54): Error: undeclared identifier: one
results/bank.bpl(75,71): Error: undeclared identifier: one
results/bank.bpl(76,76): Error: undeclared identifier: one
results/bank.bpl(76,97): Error: undeclared identifier: one
results/bank.bpl(76,109): Error: undeclared identifier: two
results/bank.bpl(77,76): Error: undeclared identifier: one
results/bank.bpl(77,93): Error: undeclared identifier: one
results/bank.bpl(79,6): Error: undeclared identifier: one
results/bank.bpl(79,35): Error: undeclared identifier: two
19 name resolution errors detected in results/bank.bpl


18-09-12 10:43 INFO    : ************ bank ***************
18-09-12 10:43 INFO    : Checking the syntax
18-09-12 10:43 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/bank.bpl(72,20): Error: undeclared identifier: j
results/bank.bpl(72,25): Error: undeclared identifier: j
2 name resolution errors detected in results/bank.bpl


18-09-12 10:43 INFO    : ************ bank ***************
18-09-12 10:43 INFO    : Checking the syntax
18-09-12 10:43 INFO    : Parsing the specification
18-09-12 10:43 INFO    : Checking the well-formedness of the specification
18-09-12 10:43 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-12 10:45 INFO    : ************ bank ***************
18-09-12 10:45 INFO    : Checking the syntax
18-09-12 10:45 INFO    : Parsing the specification
18-09-12 10:45 INFO    : Checking the well-formedness of the specification
18-09-12 10:45 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-12 10:46 INFO    : ************ bank ***************
18-09-12 10:46 INFO    : Checking the syntax
18-09-12 10:46 INFO    : Parsing the specification
18-09-12 10:46 INFO    : Checking the well-formedness of the specification
18-09-12 10:46 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-12 10:48 INFO    : ************ bank ***************
18-09-12 10:48 INFO    : Checking the syntax
18-09-12 10:48 INFO    : Parsing the specification
18-09-12 10:48 INFO    : Checking the well-formedness of the specification
18-09-12 10:48 ERROR   : Can't convert 'int' object to str implicitly

18-09-12 10:49 INFO    : ************ bank ***************
18-09-12 10:49 INFO    : Checking the syntax
18-09-12 10:49 INFO    : Parsing the specification
18-09-12 10:49 INFO    : Checking the well-formedness of the specification
18-09-12 10:49 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-12 10:49 INFO    : ************ bank ***************
18-09-12 10:49 INFO    : Checking the syntax
18-09-12 10:49 INFO    : Parsing the specification
18-09-12 10:49 INFO    : Checking the well-formedness of the specification
18-09-12 10:49 ERROR   : The greater than or equal two function must contain a pair of all the variables defined

18-09-12 12:50 INFO    : ************ bank ***************
18-09-12 12:50 INFO    : Checking the syntax
18-09-12 12:50 INFO    : Parsing the specification
18-09-12 12:50 INFO    : Checking the well-formedness of the specification
18-09-12 12:50 INFO    : Checking convergence
18-09-12 12:50 INFO    : Checking monotonicity for procedure deposit
18-09-12 12:50 INFO    : Checking monotonicity for procedure withdraw
18-09-12 12:50 INFO    : Checking LUB properties of merge_procprocedure
18-09-12 12:50 ERROR   : lub_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(balances,old(balances)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq_counter(balances,_balances1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _balances:[Client][ReplicaID][Txn]int::gteq_counter(_balances,old(balances)) && gteq_counter(_balances,_balances1) ==> gteq_counter(_balances,balances));
The value of parameters and variables are ::


18-09-12 13:35 INFO    : ************ bank ***************
18-09-12 13:35 INFO    : Checking the syntax
18-09-12 13:35 INFO    : Parsing the specification
18-09-12 13:35 INFO    : Checking the well-formedness of the specification
18-09-12 13:35 INFO    : Checking convergence
18-09-12 13:35 INFO    : Checking monotonicity for procedure deposit
18-09-12 13:35 INFO    : Checking monotonicity for procedure withdraw
18-09-12 13:35 INFO    : Checking LUB properties of merge_procprocedure
18-09-12 13:35 INFO    : Checking safety
18-09-12 13:35 INFO    : Checking whether deposit upholds the invariant
18-09-12 13:35 INFO    : Checking whether withdraw upholds the invariant
18-09-12 13:35 INFO    : Checking whether merge_proc upholds the invariant
18-09-12 13:35 ERROR   : safety_merge_proc::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: balances[c][r][d] -  balances[c][r][w] >= min);
The value of parameters and variables are ::

18-09-12 13:35 INFO    : Checking whether deposit upholds the precondition of merge
18-09-12 13:35 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-12 13:35 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-12 13:35 ERROR   : 

18-09-12 13:36 INFO    : ************ bank ***************
18-09-12 13:36 INFO    : Checking the syntax
18-09-12 13:36 INFO    : Parsing the specification
18-09-12 13:36 INFO    : Checking the well-formedness of the specification
18-09-12 13:36 INFO    : Checking convergence
18-09-12 13:36 INFO    : Checking monotonicity for procedure deposit
18-09-12 13:36 INFO    : Checking monotonicity for procedure withdraw
18-09-12 13:36 INFO    : Checking LUB properties of merge_procprocedure
18-09-12 13:36 INFO    : Checking safety
18-09-12 13:36 INFO    : Checking whether deposit upholds the invariant
18-09-12 13:36 INFO    : Checking whether withdraw upholds the invariant
18-09-12 13:36 INFO    : Checking whether merge_proc upholds the invariant
18-09-12 13:36 INFO    : Checking whether deposit upholds the precondition of merge
18-09-12 13:36 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-12 13:36 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-12 13:36 INFO    : The specification is safe!!!
18-09-20 09:15 INFO    : ************ bank ***************
18-09-20 09:15 INFO    : Checking the syntax
18-09-20 09:15 INFO    : Parsing the specification
18-09-20 09:15 INFO    : Checking the well-formedness of the specification
18-09-20 09:15 INFO    : Checking convergence
18-09-20 09:15 INFO    : Checking monotonicity for procedure deposit
18-09-20 09:15 INFO    : Checking monotonicity for procedure withdraw
18-09-20 09:15 INFO    : Checking LUB properties of merge_procprocedure
18-09-20 09:15 INFO    : Checking safety
18-09-20 09:15 INFO    : Checking whether deposit upholds the invariant
18-09-20 09:15 INFO    : Checking whether withdraw upholds the invariant
18-09-20 09:15 INFO    : Checking whether merge_proc upholds the invariant
18-09-20 09:15 INFO    : Checking whether deposit upholds the precondition of merge
18-09-20 09:15 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-20 09:15 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-20 09:15 INFO    : The specification is safe!!!
18-09-20 09:27 INFO    : ************ bank ***************
18-09-20 09:27 INFO    : Checking the syntax
18-09-20 09:27 INFO    : Parsing the specification
18-09-20 09:27 INFO    : Checking the well-formedness of the specification
18-09-20 09:27 INFO    : Checking convergence
18-09-20 09:27 INFO    : Checking monotonicity for procedure deposit
18-09-20 09:27 INFO    : Checking monotonicity for procedure withdraw
18-09-20 09:27 INFO    : Checking LUB properties of merge_procprocedure
18-09-20 09:27 INFO    : Checking safety
18-09-20 09:27 INFO    : Checking whether deposit upholds the invariant
18-09-20 09:28 INFO    : Checking whether withdraw upholds the invariant
18-09-20 09:28 ERROR   : safety_withdraw::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (0 <= c && c < nc && 0 <= r && r < nr) ==> (balances[c][r][d] -  balances[c][r][w] >= min));
The value of parameters and variables are ::

18-09-20 09:28 INFO    : Checking whether merge_proc upholds the invariant
18-09-20 09:28 INFO    : Checking whether deposit upholds the precondition of merge
18-09-20 09:28 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-20 09:28 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-20 09:28 ERROR   : 

18-09-20 09:28 INFO    : ************ bank ***************
18-09-20 09:28 INFO    : Checking the syntax
18-09-20 09:28 INFO    : Parsing the specification
18-09-20 09:28 INFO    : Checking the well-formedness of the specification
18-09-20 09:28 INFO    : Checking convergence
18-09-20 09:28 INFO    : Checking monotonicity for procedure deposit
18-09-20 09:28 INFO    : Checking monotonicity for procedure withdraw
18-09-20 09:28 INFO    : Checking LUB properties of merge_procprocedure
18-09-20 09:28 INFO    : Checking safety
18-09-20 09:28 INFO    : Checking whether deposit upholds the invariant
18-09-20 09:28 INFO    : Checking whether withdraw upholds the invariant
18-09-20 09:28 INFO    : Checking whether merge_proc upholds the invariant
18-09-20 09:28 INFO    : Checking whether deposit upholds the precondition of merge
18-09-20 09:28 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-20 09:28 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-20 09:28 INFO    : The specification is safe!!!
18-09-26 10:07 INFO    : ************ auction ***************
18-09-26 10:07 INFO    : Checking the syntax
18-09-26 10:07 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(50,1): error: ")" expected
1 parse errors detected in results/auction.bpl



18-09-26 10:08 INFO    : ************ auction ***************
18-09-26 10:08 INFO    : Checking the syntax
18-09-26 10:08 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(50,1): error: ")" expected
1 parse errors detected in results/auction.bpl



18-09-26 10:08 INFO    : ************ auction ***************
18-09-26 10:08 INFO    : Checking the syntax
18-09-26 10:08 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(44,103): Error: undeclared identifier: b
results/auction.bpl(44,108): Error: undeclared identifier: b
results/auction.bpl(49,424): Error: undeclared identifier: n
results/auction.bpl(49,601): Error: undeclared identifier: n
results/auction.bpl(49,766): Error: more than one declaration of variable name: a
results/auction.bpl(49,796): Error: undeclared identifier: n
results/auction.bpl(54,47): Error: undeclared identifier: n
results/auction.bpl(55,47): Error: undeclared identifier: n
results/auction.bpl(101,33): Error: undeclared identifier: promoter
9 name resolution errors detected in results/auction.bpl


18-09-26 10:09 INFO    : ************ auction ***************
18-09-26 10:09 INFO    : Checking the syntax
18-09-26 10:09 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(49,756): error: "}" expected
1 parse errors detected in results/auction.bpl



18-09-26 10:10 INFO    : ************ auction ***************
18-09-26 10:10 INFO    : Checking the syntax
18-09-26 10:10 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(44,103): Error: undeclared identifier: b
results/auction.bpl(44,108): Error: undeclared identifier: b
results/auction.bpl(52,45): Error: undeclared identifier: n
results/auction.bpl(53,45): Error: undeclared identifier: n
results/auction.bpl(54,45): Error: undeclared identifier: n
results/auction.bpl(59,47): Error: undeclared identifier: n
results/auction.bpl(60,47): Error: undeclared identifier: n
results/auction.bpl(106,33): Error: undeclared identifier: promoter
8 name resolution errors detected in results/auction.bpl


18-09-26 10:11 INFO    : ************ auction ***************
18-09-26 10:11 INFO    : Checking the syntax
18-09-26 10:11 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(45,32): Error: undeclared identifier: b
results/auction.bpl(45,37): Error: undeclared identifier: b
results/auction.bpl(60,45): Error: undeclared identifier: n
results/auction.bpl(61,45): Error: undeclared identifier: n
results/auction.bpl(62,45): Error: undeclared identifier: n
results/auction.bpl(67,47): Error: undeclared identifier: n
results/auction.bpl(68,47): Error: undeclared identifier: n
results/auction.bpl(114,33): Error: undeclared identifier: promoter
8 name resolution errors detected in results/auction.bpl


18-09-26 10:12 INFO    : ************ auction ***************
18-09-26 10:12 INFO    : Checking the syntax
18-09-26 10:12 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(44,27): Error: invalid argument types (int and UserId) to binary operator <=
results/auction.bpl(44,37): Error: invalid argument types (UserId and int) to binary operator <
results/auction.bpl(45,29): Error: invalid argument types (int and UserId) to binary operator <=
results/auction.bpl(45,39): Error: invalid argument types (UserId and int) to binary operator <
results/auction.bpl(46,33): Error: invalid argument types (int and ProductId) to binary operator <=
results/auction.bpl(46,43): Error: invalid argument types (ProductId and int) to binary operator <
results/auction.bpl(46,51): Error: invalid argument type ([UserId]bool) to unary operator !
results/auction.bpl(46,70): Error: invalid argument type ([UserId]bool) to unary operator !
results/auction.bpl(47,32): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(47,42): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(48,32): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(48,40): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(49,32): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(49,40): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(50,32): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(50,40): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(51,28): Error: invalid argument types (int and LotId) to binary operator <=
results/auction.bpl(51,36): Error: invalid argument types (LotId and int) to binary operator <
results/auction.bpl(52,28): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(52,36): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(57,30): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(57,40): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(58,29): Error: invalid argument types (int and LotId) to binary operator <=
results/auction.bpl(58,39): Error: invalid argument types (LotId and int) to binary operator <
results/auction.bpl(59,29): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(59,39): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(60,33): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(60,43): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(61,33): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(61,43): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(61,120): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(61,130): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(62,33): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(62,43): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(62,149): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(62,159): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(62,260): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(62,272): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(67,35): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(67,45): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(68,35): Error: invalid argument types (int and AuctionId) to binary operator <=
results/auction.bpl(68,45): Error: invalid argument types (AuctionId and int) to binary operator <
results/auction.bpl(69,31): Error: invalid argument types (int and LotId) to binary operator <=
results/auction.bpl(69,41): Error: invalid argument types (LotId and int) to binary operator <
results/auction.bpl(70,31): Error: invalid argument types (int and BidId) to binary operator <=
results/auction.bpl(70,41): Error: invalid argument types (BidId and int) to binary operator <
results/auction.bpl(98,56): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(98,74): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(98,88): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(99,55): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(99,73): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(101,15): Error: invalid type for argument 0 in map assignment: int (expected: UserId)
results/auction.bpl(101,33): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(101,47): Error: invalid type for argument 0 in map select: int (expected: UserId)
results/auction.bpl(113,41): Error: map select applied to a non-map: products[p]
55 type checking errors detected in results/auction.bpl



18-09-26 10:13 INFO    : ************ auction ***************
18-09-26 10:13 INFO    : Checking the syntax
18-09-26 10:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(46,51): Error: invalid argument type ([UserId]bool) to unary operator !
results/auction.bpl(46,70): Error: invalid argument type ([UserId]bool) to unary operator !
results/auction.bpl(113,41): Error: map select applied to a non-map: products[p]
3 type checking errors detected in results/auction.bpl



18-09-26 10:14 INFO    : ************ auction ***************
18-09-26 10:14 INFO    : Checking the syntax
18-09-26 10:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(113,41): Error: map select applied to a non-map: products[p]
1 type checking errors detected in results/auction.bpl



18-09-26 10:15 INFO    : ************ auction ***************
18-09-26 10:15 INFO    : Checking the syntax
18-09-26 10:15 INFO    : Parsing the specification
18-09-26 10:15 INFO    : Checking the well-formedness of the specification
18-09-26 10:15 INFO    : Checking convergence
18-09-26 10:15 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:15 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:15 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:22 INFO    : ************ auction ***************
18-09-26 10:22 INFO    : Checking the syntax
18-09-26 10:22 INFO    : Parsing the specification
18-09-26 10:22 INFO    : Checking the well-formedness of the specification
18-09-26 10:22 INFO    : Checking convergence
18-09-26 10:22 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:22 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:22 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:24 INFO    : ************ auction ***************
18-09-26 10:24 INFO    : Checking the syntax
18-09-26 10:24 INFO    : Parsing the specification
18-09-26 10:24 INFO    : Checking the well-formedness of the specification
18-09-26 10:24 INFO    : Checking convergence
18-09-26 10:24 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:24 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:24 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:25 INFO    : ************ auction ***************
18-09-26 10:25 INFO    : Checking the syntax
18-09-26 10:25 INFO    : Parsing the specification
18-09-26 10:25 INFO    : Checking the well-formedness of the specification
18-09-26 10:25 INFO    : Checking convergence
18-09-26 10:25 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:25 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:25 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:26 INFO    : ************ auction ***************
18-09-26 10:26 INFO    : Checking the syntax
18-09-26 10:26 INFO    : Parsing the specification
18-09-26 10:26 INFO    : Checking the well-formedness of the specification
18-09-26 10:26 INFO    : Checking convergence
18-09-26 10:26 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:26 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:26 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:30 INFO    : ************ auction ***************
18-09-26 10:30 INFO    : Checking the syntax
18-09-26 10:30 INFO    : Parsing the specification
18-09-26 10:30 INFO    : Checking the well-formedness of the specification
18-09-26 10:30 INFO    : Checking convergence
18-09-26 10:30 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:30 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:30 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:31 INFO    : ************ auction ***************
18-09-26 10:31 INFO    : Checking the syntax
18-09-26 10:31 INFO    : Parsing the specification
18-09-26 10:31 INFO    : Checking the well-formedness of the specification
18-09-26 10:31 INFO    : Checking convergence
18-09-26 10:31 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:31 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:31 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:31 INFO    : ************ auction ***************
18-09-26 10:31 INFO    : Checking the syntax
18-09-26 10:31 INFO    : Parsing the specification
18-09-26 10:31 INFO    : Checking the well-formedness of the specification
18-09-26 10:31 INFO    : Checking convergence
18-09-26 10:31 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:31 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:31 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:31 INFO    : ************ auction ***************
18-09-26 10:31 INFO    : Checking the syntax
18-09-26 10:31 INFO    : Parsing the specification
18-09-26 10:31 INFO    : Checking the well-formedness of the specification
18-09-26 10:31 INFO    : Checking convergence
18-09-26 10:31 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:32 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:32 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:37 INFO    : ************ auction ***************
18-09-26 10:37 INFO    : Checking the syntax
18-09-26 10:37 INFO    : Parsing the specification
18-09-26 10:37 INFO    : Checking the well-formedness of the specification
18-09-26 10:37 INFO    : Checking convergence
18-09-26 10:37 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:37 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:37 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:37 INFO    : ************ auction ***************
18-09-26 10:37 INFO    : Checking the syntax
18-09-26 10:37 INFO    : Parsing the specification
18-09-26 10:37 INFO    : Checking the well-formedness of the specification
18-09-26 10:37 INFO    : Checking convergence
18-09-26 10:37 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:37 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:37 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:41 INFO    : ************ auction ***************
18-09-26 10:41 INFO    : Checking the syntax
18-09-26 10:41 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(124,36): Error: undeclared identifier: q
1 name resolution errors detected in results/auction.bpl


18-09-26 10:41 INFO    : ************ auction ***************
18-09-26 10:41 INFO    : Checking the syntax
18-09-26 10:41 INFO    : Parsing the specification
18-09-26 10:41 INFO    : Checking the well-formedness of the specification
18-09-26 10:41 INFO    : Checking convergence
18-09-26 10:41 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:41 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:41 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 10:55 INFO    : ************ auction ***************
18-09-26 10:55 INFO    : Checking the syntax
18-09-26 10:55 INFO    : Parsing the specification
18-09-26 10:55 INFO    : Checking the well-formedness of the specification
18-09-26 10:55 INFO    : Checking convergence
18-09-26 10:55 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 10:55 INFO    : Checking LUB properties of mergeprocedure
18-09-26 10:55 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:01 INFO    : ************ auction ***************
18-09-26 11:01 INFO    : Checking the syntax
18-09-26 11:01 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(131,227): error: ")" expected
results/auction.bpl(131,353): error: ")" expected
2 parse errors detected in results/auction.bpl



18-09-26 11:02 INFO    : ************ auction ***************
18-09-26 11:02 INFO    : Checking the syntax
18-09-26 11:02 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(131,227): error: ")" expected
results/auction.bpl(131,296): error: "then" expected
2 parse errors detected in results/auction.bpl



18-09-26 11:04 INFO    : ************ auction ***************
18-09-26 11:04 INFO    : Checking the syntax
18-09-26 11:04 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(131,356): error: ")" expected
1 parse errors detected in results/auction.bpl



18-09-26 11:04 INFO    : ************ auction ***************
18-09-26 11:04 INFO    : Checking the syntax
18-09-26 11:04 INFO    : Parsing the specification
18-09-26 11:04 INFO    : Checking the well-formedness of the specification
18-09-26 11:04 INFO    : Checking convergence
18-09-26 11:04 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:04 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:04 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:06 INFO    : ************ auction ***************
18-09-26 11:06 INFO    : Checking the syntax
18-09-26 11:06 INFO    : Parsing the specification
18-09-26 11:06 INFO    : Checking the well-formedness of the specification
18-09-26 11:06 INFO    : Checking convergence
18-09-26 11:06 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:06 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:06 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:07 INFO    : ************ auction ***************
18-09-26 11:07 INFO    : Checking the syntax
18-09-26 11:07 INFO    : Parsing the specification
18-09-26 11:07 INFO    : Checking the well-formedness of the specification
18-09-26 11:07 INFO    : Checking convergence
18-09-26 11:07 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:07 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:07 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:09 INFO    : ************ auction ***************
18-09-26 11:09 INFO    : Checking the syntax
18-09-26 11:09 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(137,41): error: "{" expected
1 parse errors detected in results/auction.bpl



18-09-26 11:10 INFO    : ************ auction ***************
18-09-26 11:10 INFO    : Checking the syntax
18-09-26 11:10 INFO    : Parsing the specification
18-09-26 11:10 INFO    : Checking the well-formedness of the specification
18-09-26 11:10 INFO    : Checking convergence
18-09-26 11:10 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:10 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:10 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:12 INFO    : ************ auction ***************
18-09-26 11:12 INFO    : Checking the syntax
18-09-26 11:12 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(145,37): error: "{" expected
1 parse errors detected in results/auction.bpl



18-09-26 11:12 INFO    : ************ auction ***************
18-09-26 11:12 INFO    : Checking the syntax
18-09-26 11:12 INFO    : Parsing the specification
18-09-26 11:12 INFO    : Checking the well-formedness of the specification
18-09-26 11:12 INFO    : Checking convergence
18-09-26 11:12 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:12 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:12 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:15 INFO    : ************ auction ***************
18-09-26 11:15 INFO    : Checking the syntax
18-09-26 11:15 ERROR   : auction::::::
This loop invariant might not be maintained by the loop.
invariant (0 <= u && u < nu);


18-09-26 11:22 INFO    : ************ auction ***************
18-09-26 11:22 INFO    : Checking the syntax
18-09-26 11:22 ERROR   : auction::::::
This loop invariant might not be maintained by the loop.
invariant(0<=p && p < np);


18-09-26 11:22 INFO    : ************ auction ***************
18-09-26 11:22 INFO    : Checking the syntax
18-09-26 11:22 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall b:UserId :: buyers[b] == (old(buyers)[b] || buyers1[b]));
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall s:UserId :: sellers[s] == (old(sellers)[s] || sellers1[s]));
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall p:ProductId :: products[p] == (old(products)[p] || products1[p]));
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: auctions[a] == (old(auctions)[a] || auctions1[a]));
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (if (old(auction_seller)[a] == null) then (auction_seller[a] == auction_seller1[a]) else (auction_seller[a] == old(auction_seller)[a])));


18-09-26 11:23 INFO    : ************ auction ***************
18-09-26 11:23 INFO    : Checking the syntax
18-09-26 11:23 INFO    : Parsing the specification
18-09-26 11:23 INFO    : Checking the well-formedness of the specification
18-09-26 11:23 INFO    : Checking convergence
18-09-26 11:23 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:23 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:23 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:26 INFO    : ************ auction ***************
18-09-26 11:26 INFO    : Checking the syntax
18-09-26 11:26 INFO    : Parsing the specification
18-09-26 11:26 INFO    : Checking the well-formedness of the specification
18-09-26 11:26 INFO    : Checking convergence
18-09-26 11:26 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:26 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:26 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:27 INFO    : ************ auction ***************
18-09-26 11:27 INFO    : Checking the syntax
18-09-26 11:27 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));


18-09-26 11:33 INFO    : ************ auction ***************
18-09-26 11:33 INFO    : Checking the syntax
18-09-26 11:33 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));


18-09-26 11:34 INFO    : ************ auction ***************
18-09-26 11:34 INFO    : Checking the syntax
18-09-26 11:34 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));
This loop invariant might not hold on entry.
invariant (buyers == old(buyers));


18-09-26 11:35 INFO    : ************ auction ***************
18-09-26 11:35 INFO    : Checking the syntax
18-09-26 11:35 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(p<np)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));


18-09-26 11:35 INFO    : ************ auction ***************
18-09-26 11:35 INFO    : Checking the syntax
18-09-26 11:35 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(u < nu)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));


18-09-26 11:36 INFO    : ************ auction ***************
18-09-26 11:36 INFO    : Checking the syntax
18-09-26 11:36 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction.bpl(119,22): Error: more than one declaration of variable name: b
results/auction.bpl(129,22): Error: more than one declaration of variable name: b
2 name resolution errors detected in results/auction.bpl


18-09-26 11:37 INFO    : ************ auction ***************
18-09-26 11:37 INFO    : Checking the syntax
18-09-26 11:37 ERROR   : auction::::::
This loop invariant might not hold on entry.
invariant (forall i:UserId :: (0 <= i && i < nu) ==> buyers[i] == (old(buyers)[i] || buyers1[i]));


18-09-26 11:38 INFO    : ************ auction ***************
18-09-26 11:38 INFO    : Checking the syntax
18-09-26 11:38 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(u < nu)
This is the postcondition that might not hold.
ensures (forall b:UserId :: (0 <= b && b < nu) ==> buyers[b] == (old(buyers)[b] || buyers1[b]));


18-09-26 11:39 INFO    : ************ auction ***************
18-09-26 11:39 INFO    : Checking the syntax
18-09-26 11:39 INFO    : Parsing the specification
18-09-26 11:39 INFO    : Checking the well-formedness of the specification
18-09-26 11:39 INFO    : Checking convergence
18-09-26 11:39 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:39 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:39 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:40 INFO    : ************ auction ***************
18-09-26 11:40 INFO    : Checking the syntax
18-09-26 11:40 INFO    : Parsing the specification
18-09-26 11:40 INFO    : Checking the well-formedness of the specification
18-09-26 11:40 INFO    : Checking convergence
18-09-26 11:40 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:40 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:40 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:40 INFO    : ************ auction ***************
18-09-26 11:40 INFO    : Checking the syntax
18-09-26 11:40 INFO    : Parsing the specification
18-09-26 11:40 INFO    : Checking the well-formedness of the specification
18-09-26 11:40 INFO    : Checking convergence
18-09-26 11:40 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:40 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:40 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:40 INFO    : ************ auction ***************
18-09-26 11:40 INFO    : Checking the syntax
18-09-26 11:40 INFO    : Parsing the specification
18-09-26 11:40 INFO    : Checking the well-formedness of the specification
18-09-26 11:40 INFO    : Checking convergence
18-09-26 11:40 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:40 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:40 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:41 INFO    : ************ auction ***************
18-09-26 11:41 INFO    : Checking the syntax
18-09-26 11:41 INFO    : Parsing the specification
18-09-26 11:41 INFO    : Checking the well-formedness of the specification
18-09-26 11:41 INFO    : Checking convergence
18-09-26 11:41 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:41 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:41 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:41 INFO    : ************ auction ***************
18-09-26 11:41 INFO    : Checking the syntax
18-09-26 11:41 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall p:ProductId :: products[p] == (old(products)[p] || products1[p]));


18-09-26 11:41 INFO    : ************ auction ***************
18-09-26 11:41 INFO    : Checking the syntax
18-09-26 11:42 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall p:ProductId :: (0 <= p && p < np) ==> products[p] == (old(products)[p] || products1[p]));


18-09-26 11:42 INFO    : ************ auction ***************
18-09-26 11:42 INFO    : Checking the syntax
18-09-26 11:42 INFO    : Parsing the specification
18-09-26 11:42 INFO    : Checking the well-formedness of the specification
18-09-26 11:42 INFO    : Checking convergence
18-09-26 11:42 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:42 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:42 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:42 INFO    : ************ auction ***************
18-09-26 11:42 INFO    : Checking the syntax
18-09-26 11:42 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: auctions[a] == (old(auctions)[a] || auctions1[a]));


18-09-26 11:43 INFO    : ************ auction ***************
18-09-26 11:43 INFO    : Checking the syntax
18-09-26 11:43 INFO    : Parsing the specification
18-09-26 11:43 INFO    : Checking the well-formedness of the specification
18-09-26 11:43 INFO    : Checking convergence
18-09-26 11:43 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:43 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:43 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:43 INFO    : ************ auction ***************
18-09-26 11:43 INFO    : Checking the syntax
18-09-26 11:43 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (if (old(auction_seller)[a] == null) then (auction_seller[a] == auction_seller1[a]) else (auction_seller[a] == old(auction_seller)[a])));


18-09-26 11:43 INFO    : ************ auction ***************
18-09-26 11:43 INFO    : Checking the syntax
18-09-26 11:43 INFO    : Parsing the specification
18-09-26 11:43 INFO    : Checking the well-formedness of the specification
18-09-26 11:43 INFO    : Checking convergence
18-09-26 11:43 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:43 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:43 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:44 INFO    : ************ auction ***************
18-09-26 11:44 INFO    : Checking the syntax
18-09-26 11:44 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: if (old(auction_status)[a] == closed || auction_status1[a] == closed) then (auction_status[a] == closed) else (if ((old(auction_status)[a] == active || auction_status1[a] == active) && (old(auction_status)[a] == closed || auction_status1[a] == closed)) then (auction_status[a] == active) else auction_status[a] == prep));


18-09-26 11:44 INFO    : ************ auction ***************
18-09-26 11:44 INFO    : Checking the syntax
18-09-26 11:44 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> if (old(auction_status)[a] == closed || auction_status1[a] == closed) then (auction_status[a] == closed) else (if ((old(auction_status)[a] == active || auction_status1[a] == active) && (old(auction_status)[a] == closed || auction_status1[a] == closed)) then (auction_status[a] == active) else auction_status[a] == prep));


18-09-26 11:45 INFO    : ************ auction ***************
18-09-26 11:45 INFO    : Checking the syntax
18-09-26 11:45 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (if (old(auction_winner)[a] == null) then (auction_winner[a] == auction_winner1[a]) else (auction_winner[a] == old(auction_winner)[a])));


18-09-26 11:45 INFO    : ************ auction ***************
18-09-26 11:45 INFO    : Checking the syntax
18-09-26 11:45 INFO    : Parsing the specification
18-09-26 11:45 INFO    : Checking the well-formedness of the specification
18-09-26 11:45 INFO    : Checking convergence
18-09-26 11:45 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:45 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:45 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:46 INFO    : ************ auction ***************
18-09-26 11:46 INFO    : Checking the syntax
18-09-26 11:46 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(a<na)
This is the postcondition that might not hold.
ensures (forall l:LotId :: (0 <= l && l < nl) ==> lots[l] == (old(lots)[l] || lots1[l]));


18-09-26 11:49 INFO    : ************ auction ***************
18-09-26 11:49 INFO    : Checking the syntax
18-09-26 11:49 ERROR   : auction::::::
This loop invariant might not be maintained by the loop.
invariant(forall i:int:: (0<=i && i <l) ==> lots[i] == (old(lots)[i] || lots1[i]));


18-09-26 11:51 INFO    : ************ auction ***************
18-09-26 11:51 INFO    : Checking the syntax
18-09-26 11:51 INFO    : Parsing the specification
18-09-26 11:51 INFO    : Checking the well-formedness of the specification
18-09-26 11:51 INFO    : Checking convergence
18-09-26 11:51 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:51 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:51 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:53 INFO    : ************ auction ***************
18-09-26 11:53 INFO    : Checking the syntax
18-09-26 11:53 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(l<nl)
This is the postcondition that might not hold.
ensures (forall l:LotId :: (0 <= l && l < nl) ==> lot_auction[l] == old(lot_auction)[l] && lot_product[l] == old(lot_product)[l]);


18-09-26 11:54 INFO    : ************ auction ***************
18-09-26 11:54 INFO    : Checking the syntax
18-09-26 11:54 INFO    : Parsing the specification
18-09-26 11:54 INFO    : Checking the well-formedness of the specification
18-09-26 11:54 INFO    : Checking convergence
18-09-26 11:54 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:54 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:54 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 11:55 INFO    : ************ auction ***************
18-09-26 11:55 INFO    : Checking the syntax
18-09-26 11:55 INFO    : Parsing the specification
18-09-26 11:55 INFO    : Checking the well-formedness of the specification
18-09-26 11:55 INFO    : Checking convergence
18-09-26 11:55 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 11:55 INFO    : Checking LUB properties of mergeprocedure
18-09-26 11:55 ERROR   : lub_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (gteq(buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1));
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall _buyers:[UserId]bool, _sellers:[UserId]bool, _products:[ProductId]bool, _auctions:[AuctionId]bool, _auction_seller:[AuctionId]UserId, _auction_status:[AuctionId]State, _auction_winner:[AuctionId]UserId, _lots:[LotId]bool, _lot_auction:[LotId]AuctionId, _lot_product:[LotId]ProductId, _bids:[BidId]bool, _bid_auction:[BidId]AuctionId, _bid_buyer:[BidId]UserId, _bid_amount:[BidId]int::gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,old(buyers),old(sellers),old(products),old(auctions),old(auction_seller),old(auction_winner),old(auction_status),old(lots),old(lot_auction),old(lot_product),old(bids),old(bid_auction),old(bid_buyer),old(bid_amount)) && gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,_buyers1,_sellers1,_products1,_auctions1,_auction_seller1,_auction_winner1,_auction_status1,_lots1,_lot_auction1,_lot_product1,_bids1,_bid_auction1,_bid_buyer1,_bid_amount1) ==> gteq(_buyers,_sellers,_products,_auctions,_auction_seller,_auction_winner,_auction_status,_lots,_lot_auction,_lot_product,_bids,_bid_auction,_bid_buyer,_bid_amount,buyers,sellers,products,auctions,auction_seller,auction_winner,auction_status,lots,lot_auction,lot_product,bids,bid_auction,bid_buyer,bid_amount));
The value of parameters and variables are ::


18-09-26 12:27 INFO    : ************ auction ***************
18-09-26 12:27 INFO    : Checking the syntax
18-09-26 12:27 ERROR   : auction::::::
A postcondition might not hold on this return path.
while(b<nb)
This is the postcondition that might not hold.
ensures (forall b:BidId :: (0 <= b && b < nb) ==> bids[b] == (old(bids)[b] || bids1[b]));


18-09-26 12:27 INFO    : ************ auction ***************
18-09-26 12:27 INFO    : Checking the syntax
18-09-26 12:27 ERROR   : auction::::::
This loop invariant might not be maintained by the loop.
invariant(forall i:int:: (0<=i && i <b) ==> bids[i] == (old(bids)[i] || bids1[i]));


18-09-26 12:28 INFO    : ************ auction ***************
18-09-26 12:28 INFO    : Checking the syntax
18-09-26 12:28 INFO    : Parsing the specification
18-09-26 12:28 INFO    : Checking the well-formedness of the specification
18-09-26 12:28 INFO    : Checking convergence
18-09-26 12:28 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 12:28 INFO    : Checking LUB properties of mergeprocedure
18-09-26 12:28 INFO    : Checking safety
18-09-26 12:28 INFO    : Checking whether registerSeller upholds the invariant
18-09-26 12:28 INFO    : Checking whether merge upholds the invariant
18-09-26 12:28 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (sellers[auction_seller[a]] && (auction_winner[a] == null || buyers[auction_winner[a]])))
The value of parameters and variables are ::

18-09-26 12:28 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-26 12:28 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 12:28 ERROR   : 

18-09-26 12:29 INFO    : ************ auction ***************
18-09-26 12:29 INFO    : Checking the syntax
18-09-26 12:29 INFO    : Parsing the specification
18-09-26 12:29 INFO    : Checking the well-formedness of the specification
18-09-26 12:29 INFO    : Checking convergence
18-09-26 12:29 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 12:29 INFO    : Checking LUB properties of mergeprocedure
18-09-26 12:29 INFO    : Checking safety
18-09-26 12:29 INFO    : Checking whether registerSeller upholds the invariant
18-09-26 12:29 INFO    : Checking whether merge upholds the invariant
18-09-26 12:29 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (sellers[auction_seller[a]] && (auction_winner[a] == null || buyers[auction_winner[a]])))
The value of parameters and variables are ::

18-09-26 12:29 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-26 12:29 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 12:29 ERROR   : 

18-09-26 12:31 INFO    : ************ auction ***************
18-09-26 12:31 INFO    : Checking the syntax
18-09-26 12:31 ERROR   : auction::::::
This loop invariant might not be maintained by the loop.
invariant (forall i:BidId :: (0 <= i && i < nb) ==> bid_auction[i] == old(bid_auction)[i] && bid_buyer[i] == old(bid_buyer)[i] && bid_amount[i] == old(bid_amount)[i]);


18-09-26 12:31 INFO    : ************ auction ***************
18-09-26 12:31 INFO    : Checking the syntax
18-09-26 12:31 INFO    : Parsing the specification
18-09-26 12:31 INFO    : Checking the well-formedness of the specification
18-09-26 12:31 INFO    : Checking convergence
18-09-26 12:31 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 12:31 INFO    : Checking LUB properties of mergeprocedure
18-09-26 12:31 INFO    : Checking safety
18-09-26 12:31 INFO    : Checking whether registerSeller upholds the invariant
18-09-26 12:31 INFO    : Checking whether merge upholds the invariant
18-09-26 12:31 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (sellers[auction_seller[a]] && (auction_winner[a] == null || buyers[auction_winner[a]])))
The value of parameters and variables are ::

18-09-26 12:31 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-26 12:32 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 12:32 ERROR   : 

18-09-26 13:09 INFO    : ************ auction ***************
18-09-26 13:09 INFO    : Checking the syntax
18-09-26 13:09 INFO    : Parsing the specification
18-09-26 13:09 INFO    : Checking the well-formedness of the specification
18-09-26 13:09 INFO    : Checking convergence
18-09-26 13:09 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 13:09 INFO    : Checking LUB properties of mergeprocedure
18-09-26 13:09 INFO    : Checking safety
18-09-26 13:09 INFO    : Checking whether registerSeller upholds the invariant
18-09-26 13:09 INFO    : Checking whether merge upholds the invariant
18-09-26 13:09 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (sellers[auction_seller[a]] && (auction_winner[a] == null || buyers[auction_winner[a]])))
The value of parameters and variables are ::

18-09-26 13:09 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-26 13:09 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 13:09 ERROR   : 

18-09-26 13:23 INFO    : ************ auction ***************
18-09-26 13:23 INFO    : Checking the syntax
18-09-26 13:23 INFO    : Parsing the specification
18-09-26 13:23 INFO    : Checking the well-formedness of the specification
18-09-26 13:23 INFO    : Checking convergence
18-09-26 13:23 INFO    : Checking monotonicity for procedure registerSeller
18-09-26 13:23 INFO    : Checking LUB properties of mergeprocedure
18-09-26 13:23 INFO    : Checking safety
18-09-26 13:23 INFO    : Checking whether registerSeller upholds the invariant
18-09-26 13:23 INFO    : Checking whether merge upholds the invariant
18-09-26 13:23 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (sellers[auction_seller[a]] && (auction_winner[a] == null || buyers[auction_winner[a]])))
The value of parameters and variables are ::

18-09-26 13:23 INFO    : Checking whether registerSeller upholds the precondition of merge
18-09-26 13:23 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 13:23 ERROR   : 

18-09-26 13:24 INFO    : ************ auction_scaled_down ***************
18-09-26 13:24 INFO    : Checking the syntax
18-09-26 13:24 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(35,121): error: "}" expected
1 parse errors detected in results/auction_scaled_down.bpl



18-09-26 13:24 INFO    : ************ auction_scaled_down ***************
18-09-26 13:24 INFO    : Checking the syntax
18-09-26 13:24 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(57,39): Error: undeclared type: UserId
1 name resolution errors detected in results/auction_scaled_down.bpl


18-09-26 13:24 INFO    : ************ auction_scaled_down ***************
18-09-26 13:24 INFO    : Checking the syntax
18-09-26 13:24 INFO    : Parsing the specification
18-09-26 13:24 INFO    : Checking the well-formedness of the specification
18-09-26 13:24 INFO    : Checking convergence
18-09-26 13:24 INFO    : Checking LUB properties of mergeprocedure
18-09-26 13:24 INFO    : Checking safety
18-09-26 13:24 INFO    : Checking whether merge upholds the invariant
18-09-26 13:25 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-26 13:25 INFO    : Checking whether merge upholds the precondition of itself
18-09-26 13:25 ERROR   : 

18-09-27 09:05 INFO    : ************ bank ***************
18-09-27 09:05 INFO    : Checking the syntax
18-09-27 09:05 INFO    : Parsing the specification
18-09-27 09:05 INFO    : Checking the well-formedness of the specification
18-09-27 09:05 INFO    : Checking convergence
18-09-27 09:05 INFO    : Checking monotonicity for procedure deposit
18-09-27 09:05 ERROR   : monotonicity_deposit::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_counter(balances,old(balances));
The value of parameters and variables are ::


18-09-27 09:05 INFO    : ************ bank ***************
18-09-27 09:05 INFO    : Checking the syntax
18-09-27 09:05 INFO    : Parsing the specification
18-09-27 09:05 INFO    : Checking the well-formedness of the specification
18-09-27 09:05 INFO    : Checking convergence
18-09-27 09:05 INFO    : Checking monotonicity for procedure deposit
18-09-27 09:05 INFO    : Checking monotonicity for procedure withdraw
18-09-27 09:05 INFO    : Checking LUB properties of merge_procprocedure
18-09-27 09:05 INFO    : Checking safety
18-09-27 09:05 INFO    : Checking whether deposit upholds the invariant
18-09-27 09:05 INFO    : Checking whether withdraw upholds the invariant
18-09-27 09:05 ERROR   : safety_withdraw::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall c:Client, r:ReplicaID :: (0 <= c && c < nc && 0 <= r && r < nr) ==> (balances[c][r][d] -  balances[c][r][w] >= min));
The value of parameters and variables are ::

18-09-27 09:05 INFO    : Checking whether merge_proc upholds the invariant
18-09-27 09:05 INFO    : Checking whether deposit upholds the precondition of merge
18-09-27 09:05 INFO    : Checking whether withdraw upholds the precondition of merge
18-09-27 09:05 INFO    : Checking whether merge_proc upholds the precondition of itself
18-09-27 09:05 ERROR   : 

18-09-27 09:06 INFO    : ************ bank ***************
18-09-27 09:06 INFO    : Checking the syntax
18-09-27 09:06 INFO    : Parsing the specification
18-09-27 09:06 INFO    : Checking the well-formedness of the specification
18-09-27 09:06 INFO    : Checking convergence
18-09-27 09:06 INFO    : Checking monotonicity for procedure deposit
18-09-27 09:06 INFO    : Checking monotonicity for procedure withdraw
18-09-27 09:06 ERROR   : monotonicity_withdraw::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq_counter(balances,old(balances));
The value of parameters and variables are ::


18-09-27 09:07 INFO    : ************ token ***************
18-09-27 09:07 INFO    : Checking the syntax
18-09-27 09:07 INFO    : Parsing the specification
18-09-27 09:07 INFO    : Checking the well-formedness of the specification
18-09-27 09:07 INFO    : Checking convergence
18-09-27 09:07 INFO    : Checking monotonicity for procedure transfer
18-09-27 09:07 INFO    : Checking LUB properties of mergeprocedure
18-09-27 09:07 INFO    : Checking safety
18-09-27 09:07 INFO    : Checking whether transfer upholds the invariant
18-09-27 09:07 INFO    : Checking whether merge upholds the invariant
18-09-27 09:07 INFO    : Checking whether transfer upholds the precondition of merge
18-09-27 09:07 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 09:07 INFO    : The specification is safe!!!
18-09-27 09:07 INFO    : ************ token ***************
18-09-27 09:07 INFO    : Checking the syntax
18-09-27 09:07 INFO    : Parsing the specification
18-09-27 09:07 INFO    : Checking the well-formedness of the specification
18-09-27 09:07 INFO    : Checking convergence
18-09-27 09:07 INFO    : Checking monotonicity for procedure transfer
18-09-27 09:07 INFO    : Checking LUB properties of mergeprocedure
18-09-27 09:07 INFO    : Checking safety
18-09-27 09:07 INFO    : Checking whether transfer upholds the invariant
18-09-27 09:07 INFO    : Checking whether merge upholds the invariant
18-09-27 09:07 INFO    : Checking whether transfer upholds the precondition of merge
18-09-27 09:07 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 09:07 INFO    : The specification is safe!!!
18-09-27 09:08 INFO    : ************ token ***************
18-09-27 09:08 INFO    : Checking the syntax
18-09-27 09:08 ERROR   : token::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall r:ReplicaId :: (r != to ==> V[r] == 0));


18-09-27 09:56 INFO    : ************ auction_scaled_down ***************
18-09-27 09:56 INFO    : Checking the syntax
18-09-27 09:56 INFO    : Parsing the specification
18-09-27 09:56 INFO    : Checking the well-formedness of the specification
18-09-27 09:56 INFO    : Checking convergence
18-09-27 09:56 INFO    : Checking LUB properties of mergeprocedure
18-09-27 09:56 INFO    : Checking safety
18-09-27 09:56 INFO    : Checking whether merge upholds the invariant
18-09-27 09:56 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 09:56 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 09:56 ERROR   : 

18-09-27 11:51 INFO    : ************ auction_scaled_down ***************
18-09-27 11:51 INFO    : Checking the syntax
18-09-27 11:51 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(44,53): Error: undeclared type: UserId
results/auction_scaled_down.bpl(45,15): Error: undeclared identifier: a
results/auction_scaled_down.bpl(45,20): Error: undeclared identifier: a
results/auction_scaled_down.bpl(44,53): Error: undeclared type: UserId
4 name resolution errors detected in results/auction_scaled_down.bpl


18-09-27 11:52 INFO    : ************ auction_scaled_down ***************
18-09-27 11:52 INFO    : Checking the syntax
18-09-27 11:52 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(49,25): Error: command assigns to a global variable that is not in the enclosing procedure's modifies clause: auctions
results/auction_scaled_down.bpl(50,31): Error: command assigns to a global variable that is not in the enclosing procedure's modifies clause: auction_status
results/auction_scaled_down.bpl(51,31): Error: command assigns to a global variable that is not in the enclosing procedure's modifies clause: auction_winner
3 type checking errors detected in results/auction_scaled_down.bpl



18-09-27 11:52 INFO    : ************ auction_scaled_down ***************
18-09-27 11:52 INFO    : Checking the syntax
18-09-27 11:52 INFO    : Parsing the specification
18-09-27 11:52 INFO    : Checking the well-formedness of the specification
18-09-27 11:52 INFO    : Checking convergence
18-09-27 11:52 INFO    : Checking monotonicity for procedure createAuction
18-09-27 11:52 ERROR   : monotonicity_createAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq(auctions,auction_winner,auction_status,bids,bid_auction,bid_amount,old(auctions),old(auction_winner),old(auction_status),old(bids),old(bid_auction),old(bid_amount));
The value of parameters and variables are ::


18-09-27 12:05 INFO    : ************ auction_scaled_down ***************
18-09-27 12:05 INFO    : Checking the syntax
18-09-27 12:05 INFO    : Parsing the specification
18-09-27 12:05 INFO    : Checking the well-formedness of the specification
18-09-27 12:05 INFO    : Checking convergence
18-09-27 12:05 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:05 INFO    : Checking LUB properties of mergeprocedure
18-09-27 12:05 INFO    : Checking safety
18-09-27 12:05 INFO    : Checking whether createAuction upholds the invariant
18-09-27 12:05 ERROR   : safety_createAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:05 INFO    : Checking whether merge upholds the invariant
18-09-27 12:05 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:05 INFO    : Checking whether createAuction upholds the precondition of merge
18-09-27 12:05 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 12:05 ERROR   : 

18-09-27 12:08 INFO    : ************ auction_scaled_down ***************
18-09-27 12:08 INFO    : Checking the syntax
18-09-27 12:08 INFO    : Parsing the specification
18-09-27 12:08 INFO    : Checking the well-formedness of the specification
18-09-27 12:08 INFO    : Checking convergence
18-09-27 12:08 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:08 INFO    : Checking monotonicity for procedure startAuction
18-09-27 12:08 INFO    : Checking LUB properties of mergeprocedure
18-09-27 12:08 INFO    : Checking safety
18-09-27 12:08 INFO    : Checking whether createAuction upholds the invariant
18-09-27 12:08 ERROR   : safety_createAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:08 INFO    : Checking whether startAuction upholds the invariant
18-09-27 12:08 INFO    : Checking whether merge upholds the invariant
18-09-27 12:08 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:08 INFO    : Checking whether createAuction upholds the precondition of merge
18-09-27 12:08 INFO    : Checking whether startAuction upholds the precondition of merge
18-09-27 12:08 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 12:08 ERROR   : 

18-09-27 12:14 INFO    : ************ auction_scaled_down ***************
18-09-27 12:14 INFO    : Checking the syntax
18-09-27 12:14 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(65,18): Error: undeclared identifier: auction
results/auction_scaled_down.bpl(68,14): Error: undeclared identifier: identifier
2 name resolution errors detected in results/auction_scaled_down.bpl


18-09-27 12:15 INFO    : ************ auction_scaled_down ***************
18-09-27 12:15 INFO    : Checking the syntax
18-09-27 12:15 INFO    : Parsing the specification
18-09-27 12:15 INFO    : Checking the well-formedness of the specification
18-09-27 12:15 INFO    : Checking convergence
18-09-27 12:15 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:15 INFO    : Checking monotonicity for procedure startAuction
18-09-27 12:15 INFO    : Checking monotonicity for procedure addBid
18-09-27 12:15 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/monotonicity_addBid.bpl(172,96): Error: undeclared identifier: bid__amount
1 name resolution errors detected in results/monotonicity_addBid.bpl


18-09-27 12:16 INFO    : ************ auction_scaled_down ***************
18-09-27 12:16 INFO    : Checking the syntax
18-09-27 12:16 INFO    : Parsing the specification
18-09-27 12:16 INFO    : Checking the well-formedness of the specification
18-09-27 12:16 INFO    : Checking convergence
18-09-27 12:16 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:16 INFO    : Checking monotonicity for procedure startAuction
18-09-27 12:16 INFO    : Checking monotonicity for procedure addBid
18-09-27 12:16 INFO    : Checking LUB properties of mergeprocedure
18-09-27 12:16 INFO    : Checking safety
18-09-27 12:16 INFO    : Checking whether createAuction upholds the invariant
18-09-27 12:16 ERROR   : safety_createAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:16 INFO    : Checking whether startAuction upholds the invariant
18-09-27 12:16 INFO    : Checking whether addBid upholds the invariant
18-09-27 12:16 ERROR   : safety_addBid::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:16 INFO    : Checking whether merge upholds the invariant
18-09-27 12:16 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:16 INFO    : Checking whether createAuction upholds the precondition of merge
18-09-27 12:16 INFO    : Checking whether startAuction upholds the precondition of merge
18-09-27 12:16 INFO    : Checking whether addBid upholds the precondition of merge
18-09-27 12:16 ERROR   : stability_addBid::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (auction_winner[a] == null) || (auction_winner1[a] == null) || auction_winner[a] == auction_winner1[a]) && (forall b:BidId :: (0 <= b && b < nb) ==> bid_auction[b] == bid_auction1[b] && bid_amount[b] == bid_amount1[b]);
The value of parameters and variables are ::

18-09-27 12:16 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 12:16 ERROR   : 

18-09-27 12:27 INFO    : ************ auction_scaled_down ***************
18-09-27 12:27 INFO    : Checking the syntax
18-09-27 12:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(85,96): error: invalid UnaryExpression
1 parse errors detected in results/auction_scaled_down.bpl



18-09-27 12:28 INFO    : ************ auction_scaled_down ***************
18-09-27 12:28 INFO    : Checking the syntax
18-09-27 12:28 ERROR   : Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
results/auction_scaled_down.bpl(84,58): Error: undeclared identifier: identifier
results/auction_scaled_down.bpl(84,133): Error: undeclared identifier: identifier
results/auction_scaled_down.bpl(85,58): Error: undeclared identifier: identifier
results/auction_scaled_down.bpl(85,138): Error: undeclared identifier: identifier
4 name resolution errors detected in results/auction_scaled_down.bpl


18-09-27 12:29 INFO    : ************ auction_scaled_down ***************
18-09-27 12:29 INFO    : Checking the syntax
18-09-27 12:29 INFO    : Parsing the specification
18-09-27 12:29 INFO    : Checking the well-formedness of the specification
18-09-27 12:29 INFO    : Checking convergence
18-09-27 12:29 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:29 INFO    : Checking monotonicity for procedure startAuction
18-09-27 12:29 INFO    : Checking monotonicity for procedure addBid
18-09-27 12:29 INFO    : Checking monotonicity for procedure closeAuction
18-09-27 12:29 ERROR   : monotonicity_closeAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures gteq(auctions,auction_winner,auction_status,bids,bid_auction,bid_amount,old(auctions),old(auction_winner),old(auction_status),old(bids),old(bid_auction),old(bid_amount));
The value of parameters and variables are ::


18-09-27 12:29 INFO    : ************ auction_scaled_down ***************
18-09-27 12:29 INFO    : Checking the syntax
18-09-27 12:29 INFO    : Parsing the specification
18-09-27 12:29 INFO    : Checking the well-formedness of the specification
18-09-27 12:29 INFO    : Checking convergence
18-09-27 12:29 INFO    : Checking monotonicity for procedure createAuction
18-09-27 12:29 INFO    : Checking monotonicity for procedure startAuction
18-09-27 12:29 INFO    : Checking monotonicity for procedure addBid
18-09-27 12:29 INFO    : Checking monotonicity for procedure closeAuction
18-09-27 12:29 INFO    : Checking LUB properties of mergeprocedure
18-09-27 12:29 INFO    : Checking safety
18-09-27 12:29 INFO    : Checking whether createAuction upholds the invariant
18-09-27 12:29 ERROR   : safety_createAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:29 INFO    : Checking whether startAuction upholds the invariant
18-09-27 12:29 INFO    : Checking whether addBid upholds the invariant
18-09-27 12:29 ERROR   : safety_addBid::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:29 INFO    : Checking whether closeAuction upholds the invariant
18-09-27 12:30 ERROR   : safety_closeAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:30 INFO    : Checking whether merge upholds the invariant
18-09-27 12:30 ERROR   : safety_merge::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na && auctions[a]) ==> (auction_winner[a] == null || bids[auction_winner[a]]))
The value of parameters and variables are ::

18-09-27 12:30 INFO    : Checking whether createAuction upholds the precondition of merge
18-09-27 12:30 INFO    : Checking whether startAuction upholds the precondition of merge
18-09-27 12:30 INFO    : Checking whether addBid upholds the precondition of merge
18-09-27 12:30 ERROR   : stability_addBid::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (auction_winner[a] == null) || (auction_winner1[a] == null) || auction_winner[a] == auction_winner1[a]) && (forall b:BidId :: (0 <= b && b < nb) ==> bid_auction[b] == bid_auction1[b] && bid_amount[b] == bid_amount1[b]);
The value of parameters and variables are ::

18-09-27 12:30 INFO    : Checking whether closeAuction upholds the precondition of merge
18-09-27 12:30 ERROR   : stability_closeAuction::::::
A postcondition might not hold on this return path.
}
This is the postcondition that might not hold.
ensures (forall a:AuctionId :: (0 <= a && a < na) ==> (auction_winner[a] == null) || (auction_winner1[a] == null) || auction_winner[a] == auction_winner1[a]) && (forall b:BidId :: (0 <= b && b < nb) ==> bid_auction[b] == bid_auction1[b] && bid_amount[b] == bid_amount1[b]);
The value of parameters and variables are ::

18-09-27 12:30 INFO    : Checking whether merge upholds the precondition of itself
18-09-27 12:30 ERROR   : 

